<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExternalIndexerListener.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.earthquake.indexer</a> &gt; <span class="el_source">ExternalIndexerListener.java</span></div><h1>ExternalIndexerListener.java</h1><pre class="source lang-java linenums">/*
 * ExternalIndexerListener
 */
package gov.usgs.earthquake.indexer;

import gov.usgs.earthquake.distribution.CLIProductBuilder;
import gov.usgs.earthquake.distribution.ConfigurationException;
import gov.usgs.earthquake.distribution.ExternalNotificationListener;
import gov.usgs.earthquake.distribution.FileProductStorage;
import gov.usgs.earthquake.distribution.HeartbeatListener;
import gov.usgs.earthquake.distribution.ProductAlreadyInStorageException;
import gov.usgs.earthquake.distribution.ProductStorage;
import gov.usgs.earthquake.indexer.IndexerChange.IndexerChangeType;
import gov.usgs.earthquake.product.Content;
import gov.usgs.earthquake.product.Product;
import gov.usgs.earthquake.product.ProductId;
import gov.usgs.util.Config;
import gov.usgs.util.StreamUtils;
import gov.usgs.util.XmlUtils;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * ExternalIndexerListener triggers external, non-Java listener processes.
 *
 * Provides a translation to a command-line interface
 * for the product indexer to speak with external, non-Java listeners.
 *
 * As a child-class of the AbstractListener, this also accepts the following
 * configration parameters:
 *
 * &lt;dl&gt;
 * &lt;dt&gt;command&lt;/dt&gt;
 * &lt;dd&gt;(Required) The command to execute. This must be an executable command and
 * may include arguments. Any product-specific arguments are appended at the end
 * of command.&lt;/dd&gt;
 *
 * &lt;dt&gt;storage&lt;/dt&gt;
 * &lt;dd&gt;(Required) A directory used to store all products. Each product is
 * extracted into a separate directory within this directory and is referenced
 * by the --directory=/path/to/directory argument when command is executed.&lt;/dd&gt;
 *
 * &lt;dt&gt;processUnassociated&lt;/dt&gt;
 * &lt;dd&gt;(Optional, Default = false) Whether or not to process unassociated
 * products. Valid values are &quot;true&quot; and &quot;false&quot;.&lt;/dd&gt;
 *
 * &lt;dt&gt;processPreferredOnly&lt;/dt&gt;
 * &lt;dd&gt;(Optional, Default = false) Whether or not to process only preferred
 * products of the type accepted by this listener. Valid values are &quot;true&quot; and
 * &quot;false&quot;.&lt;/dd&gt;
 *
 * &lt;dt&gt;autoArchive&lt;/dt&gt;
 * &lt;dd&gt;(Optional, Default = false) Whether or not to archive products from
 * storage when they are archived by the indexer.&lt;/dd&gt;
 *
 * &lt;/dl&gt;
 */
public class ExternalIndexerListener extends DefaultIndexerListener {

<span class="fc" id="L69">	private static final Logger LOGGER = Logger</span>
<span class="fc" id="L70">			.getLogger(ExternalIndexerListener.class.getName());</span>

	/** Argument for event action */
	public static final String EVENT_ACTION_ARGUMENT = &quot;--action=&quot;;
	/** Argument for event ids */
	public static final String EVENT_IDS_ARGUMENT = &quot;--eventids=&quot;;

	/** Argument for preferred event id */
	public static final String PREFERRED_ID_ARGUMENT = &quot;--preferred-eventid=&quot;;
	/** Argument for preferred eventsource */
	public static final String PREFERRED_EVENTSOURCE_ARGUMENT = &quot;--preferred-eventsource=&quot;;
	/** Argument for preferred eventsourcecode */
	public static final String PREFERRED_EVENTSOURCECODE_ARGUMENT = &quot;--preferred-eventsourcecode=&quot;;
	/** Argument for preferred magnitude */
	public static final String PREFERRED_MAGNITUDE_ARGUMENT = &quot;--preferred-magnitude=&quot;;
	/** Argument for preferred longitude */
	public static final String PREFERRED_LONGITUDE_ARGUMENT = &quot;--preferred-longitude=&quot;;
	/** Argument for preferred latitude */
	public static final String PREFERRED_LATITUDE_ARGUMENT = &quot;--preferred-latitude=&quot;;
	/** Argument for preferred depth */
	public static final String PREFERRED_DEPTH_ARGUMENT = &quot;--preferred-depth=&quot;;
	/** Argument for preferred eventitme */
	public static final String PREFERRED_ORIGIN_TIME_ARGUMENT = &quot;--preferred-eventtime=&quot;;
	/** Configuration parameter for storage directory product. */
	public static final String STORAGE_NAME_PROPERTY = &quot;storage&quot;;

	/** Short circuit to directly configure storage directory. */
	public static final String STORAGE_DIRECTORY_PROPERTY = &quot;storageDirectory&quot;;

	/** Configuration parameter for command. */
	public static final String COMMAND_PROPERTY = &quot;command&quot;;

	/** Configuration parameter for autoArchive. */
	public static final String AUTO_ARCHIVE_PROPERTY = &quot;autoArchive&quot;;
	/** Default state for auto archive */
	public static final String AUTO_ARCHIVE_DEFAULT = &quot;true&quot;;

	/** Argument used to pass signature to external process. */
	public static final String SIGNATURE_ARGUMENT = &quot;--signature=&quot;;

	/** Where products are stored in extracted form. */
	private FileProductStorage storage;

	/** Command that is executed after a product is stored. */
	private String command;

	/** Archive products from listener storage when archived by indexer. */
<span class="fc" id="L117">	private boolean autoArchive = false;</span>

	/**
	 * Construct a new ExternalIndexerListener object
	 *
	 * The listener must be configured with a FileProductStorage and a command
	 * to function.
	 */
	public ExternalIndexerListener() {
<span class="fc" id="L126">		super();</span>
<span class="fc" id="L127">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see gov.usgs.earthquake.indexer.IndexerListener#onIndexerEvent(gov.usgs.
	 * earthquake.indexer.IndexerEvent)
	 */
	public void onIndexerEvent(IndexerEvent change) throws Exception {
		// Only handle products that are specifically included, unless there are
		// no specified inclusions, and do not handle products that are
		// specifically excluded.
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">		if (accept(change)) {</span>
			// store product first
<span class="fc" id="L141">			Product product = storeProduct(change.getProduct());</span>

<span class="fc" id="L143">			for (Iterator&lt;IndexerChange&gt; changeIter = change</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">					.getIndexerChanges().iterator(); changeIter.hasNext();) {</span>
<span class="fc" id="L145">				IndexerChange indexerChange = changeIter.next();</span>

				// check if we should process this change
<span class="fc bfc" id="L148" title="All 2 branches covered.">				if (!accept(change, indexerChange)) {</span>
<span class="fc" id="L149">					continue;</span>
				}

				// build command
<span class="fc" id="L153">				final String indexerCommand = getProductSummaryCommand(change,</span>
						indexerChange);

<span class="fc" id="L156">				runProductCommand(indexerCommand, product);</span>
<span class="fc" id="L157">			}</span>
		}

<span class="pc bpc" id="L160" title="1 of 2 branches missed.">		if (autoArchive) {</span>
<span class="nc" id="L161">			Iterator&lt;IndexerChange&gt; changeIter = change.getIndexerChanges()</span>
<span class="nc" id="L162">					.iterator();</span>
<span class="nc" id="L163">			ProductStorage storage = getStorage();</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">			while (changeIter.hasNext()) {</span>
<span class="nc" id="L165">				IndexerChange nextChange = changeIter.next();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">				if (nextChange.getType() == IndexerChangeType.PRODUCT_ARCHIVED) {</span>
					// one product being archived
<span class="nc bnc" id="L168" title="All 2 branches missed.">					if (change.getSummary() != null) {</span>
<span class="nc" id="L169">						ProductId productId = change.getSummary().getId();</span>
<span class="nc" id="L170">						LOGGER.log(Level.FINER,</span>
<span class="nc" id="L171">								&quot;[&quot; + getName() + &quot;] auto archiving product &quot;</span>
<span class="nc" id="L172">										+ productId.toString());</span>
<span class="nc" id="L173">						storage.removeProduct(productId);</span>
<span class="nc" id="L174">					}</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">				} else if (nextChange.getType() == IndexerChangeType.EVENT_ARCHIVED) {</span>
					// all products on event being archived
<span class="nc" id="L177">					Event changeEvent = nextChange.getOriginalEvent();</span>
<span class="nc" id="L178">					LOGGER.log(Level.FINER,</span>
<span class="nc" id="L179">							&quot;[&quot; + getName() + &quot;] auto archiving event &quot;</span>
<span class="nc" id="L180">									+ changeEvent.getEventId() + &quot; products&quot;);</span>
<span class="nc" id="L181">					Iterator&lt;ProductSummary&gt; productIter = changeEvent</span>
<span class="nc" id="L182">							.getAllProductList().iterator();</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">					while (productIter.hasNext()) {</span>
<span class="nc" id="L184">						ProductId productId = productIter.next().getId();</span>
<span class="nc" id="L185">						LOGGER.log(Level.FINER,</span>
<span class="nc" id="L186">								&quot;[&quot; + getName() + &quot;] auto archiving product &quot;</span>
<span class="nc" id="L187">										+ productId.toString());</span>
<span class="nc" id="L188">						storage.removeProduct(productId);</span>
<span class="nc" id="L189">					}</span>
				}
<span class="nc" id="L191">			}</span>
		}
<span class="fc" id="L193">	}</span>

	/**
	 * Store product associated with the change.
	 *
	 * @param product product to be stored.
	 * @return a new product object, read from the listener storage.
	 * @throws Exception if error occurs
	 */
	public Product storeProduct(final Product product) throws Exception {
<span class="fc" id="L203">		Product listenerProduct = null;</span>
		try {
<span class="fc bfc" id="L205" title="All 2 branches covered.">			if (product != null) {</span>
<span class="nc" id="L206">				getStorage().storeProduct(product);</span>
<span class="nc" id="L207">				listenerProduct = getStorage().getProduct(product.getId());</span>
			} else {
<span class="fc" id="L209">				LOGGER.finer(&quot;[&quot; + getName()</span>
						+ &quot;] Change product is null. Probably archiving.&quot;);
			}
<span class="fc" id="L212">		} catch (ProductAlreadyInStorageException paise) {</span>
<span class="fc" id="L213">			LOGGER.info(&quot;[&quot; + getName() + &quot;] product already in storage&quot;);</span>
			// keep going anyways, but load from local storage
<span class="fc" id="L215">			listenerProduct = getStorage().getProduct(product.getId());</span>
<span class="fc" id="L216">		}</span>

<span class="fc" id="L218">		return listenerProduct;</span>
	}

	/**
	 * Run a product command.
	 *
	 * @param command command and arguments.
	 * @param product product, when set and empty content (path &quot;&quot;) is defined,
	 *        the content is provided to the command on stdin.
	 * @throws Exception if error occurs
	 */
	public void runProductCommand(final String command, final Product product) throws Exception {
		// execute
<span class="fc" id="L231">		LOGGER.info(&quot;[&quot; + getName() + &quot;] running command &quot; + command);</span>
<span class="fc" id="L232">		final Process process = Runtime.getRuntime().exec(command);</span>

		// Stream content over stdin if it exists
<span class="fc bfc" id="L235" title="All 2 branches covered.">		if (product != null) {</span>
<span class="fc" id="L236">			Content content = product.getContents().get(&quot;&quot;);</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">			if (content != null) {</span>
<span class="fc" id="L238">				StreamUtils.transferStream(content.getInputStream(),</span>
<span class="fc" id="L239">						process.getOutputStream());</span>
			}
		}

		// Close the output stream
<span class="fc" id="L244">		StreamUtils.closeStream(process.getOutputStream());</span>

		final Timer commandTimer;
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">		if (this.getTimeout() &gt; 0) {</span>
<span class="nc" id="L248">			 commandTimer = new Timer();</span>
			// Schedule process destruction for commandTimeout
			// milliseconds in the future
<span class="nc" id="L251">			commandTimer.schedule(new TimerTask() {</span>
				public void run() {
<span class="nc" id="L253">					LOGGER.warning(&quot;[&quot; + getName()</span>
							+ &quot;] command timeout '&quot; + command
							+ &quot;', destroying process.&quot;);
<span class="nc" id="L256">					process.destroy();</span>
<span class="nc" id="L257">				}</span>
<span class="nc" id="L258">			}, this.getTimeout());</span>
		} else {
<span class="fc" id="L260">			commandTimer = null;</span>
		}

		try {
			// Wait for process to complete
<span class="fc" id="L265">			process.waitFor();</span>
		} finally {
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">			if (commandTimer != null) {</span>
				// Cancel the timer if it was not triggered
<span class="nc" id="L269">				commandTimer.cancel();</span>
			}
		}
<span class="fc" id="L272">		LOGGER.info(&quot;[&quot; + getName() + &quot;] command '&quot; + command</span>
<span class="fc" id="L273">				+ &quot;' exited with status '&quot; + process.exitValue() + &quot;'&quot;);</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">		if (process.exitValue() != 0) {</span>
<span class="nc" id="L275">			byte[] errorOutput = StreamUtils.readStream(process.getErrorStream());</span>
<span class="nc" id="L276">			LOGGER.fine(&quot;[&quot; + getName() + &quot;] command '&quot; + command + &quot;' stderr output '&quot; +</span>
					new String(errorOutput) + &quot;'&quot;);
		}
<span class="fc" id="L279">		StreamUtils.closeStream(process.getErrorStream());</span>

		// send heartbeat info
<span class="fc" id="L282">		HeartbeatListener.sendHeartbeatMessage(getName(), &quot;command&quot;, command);</span>
<span class="fc" id="L283">		HeartbeatListener.sendHeartbeatMessage(getName(), &quot;exit value&quot;,</span>
<span class="fc" id="L284">				Integer.toString(process.exitValue()));</span>
<span class="fc" id="L285">	}</span>

	/**
	 * Get the product command and add the indexer arguments to it.
	 *
	 * @param change
	 *            The IndexerEvent received by the ExternalIndexerListener
	 * @param indexerChange
	 *            The IndexerChange
	 * @return the command to execute with its arguments as a string
	 * @throws Exception if error occurs
	 */
	public String getProductSummaryCommand(IndexerEvent change,
			IndexerChange indexerChange) throws Exception {
<span class="fc" id="L299">		ProductSummary summary = change.getSummary();</span>

<span class="fc" id="L301">		Event event = indexerChange.getNewEvent();</span>
		// When archiving events include event information
<span class="fc bfc" id="L303" title="All 4 branches covered.">		if (event == null &amp;&amp; indexerChange.getType() == IndexerChangeType.EVENT_ARCHIVED) {</span>
<span class="fc" id="L304">			event = indexerChange.getOriginalEvent();</span>
		}

<span class="fc" id="L307">		String command = getProductSummaryCommand(event, summary);</span>

		// Tells external indexer what type of index event occurred.
<span class="fc" id="L310">		command = command + &quot; &quot; +</span>
				ExternalIndexerListener.EVENT_ACTION_ARGUMENT +
<span class="fc" id="L312">				indexerChange.getType().toString();</span>

<span class="fc" id="L314">		return command;</span>
	}

	/**
	 * Get the command for a specific event and summary.
	 *
	 * @param event Specific event
	 * @param summary Specific product summary
	 * @return command line arguments as a string.
	 * @throws Exception if error occurs
	 */
	public String getProductSummaryCommand(Event event, ProductSummary summary) throws Exception {
<span class="fc" id="L326">		StringBuffer indexerCommand = new StringBuffer(getCommand());</span>

<span class="fc bfc" id="L328" title="All 2 branches covered.">		if (event != null) {</span>
<span class="fc" id="L329">			indexerCommand.append(getEventArguments(event));</span>
		}
<span class="fc bfc" id="L331" title="All 2 branches covered.">		if (summary != null) {</span>
<span class="fc" id="L332">			indexerCommand.append(getProductSummaryArguments(summary));</span>
		}


<span class="fc" id="L336">		Product product = null;</span>
		try {
<span class="fc" id="L338">			product = getStorage().getProduct(summary.getId());</span>
<span class="fc" id="L339">		} catch (Exception e) {</span>
			// when archiving product may not exist
<span class="fc" id="L341">			LOGGER.log(</span>
					Level.FINE,
					&quot;Exception retreiving product from storage, probably archiving&quot;,
					e);
<span class="fc" id="L345">		}</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">		if (product != null) {</span>
			// Can only add these arguments if there is a product
<span class="fc" id="L348">			Content content = product.getContents().get(&quot;&quot;);</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">			if (content != null) {</span>
<span class="fc" id="L350">				indexerCommand.append(&quot; &quot;).append(</span>
						CLIProductBuilder.CONTENT_ARGUMENT);
<span class="fc" id="L352">				indexerCommand.append(&quot; &quot;)</span>
<span class="fc" id="L353">						.append(CLIProductBuilder.CONTENT_TYPE_ARGUMENT)</span>
<span class="fc" id="L354">						.append(content.getContentType());</span>
			}

<span class="fc bfc" id="L357" title="All 2 branches covered.">			if (product.getSignature() != null) {</span>
<span class="fc" id="L358">				indexerCommand</span>
<span class="fc" id="L359">						.append(&quot; &quot;)</span>
<span class="fc" id="L360">						.append(ExternalNotificationListener.SIGNATURE_ARGUMENT)</span>
<span class="fc" id="L361">						.append(product.getSignature());</span>
			}

		}

<span class="fc" id="L366">		return indexerCommand.toString();</span>
	}

	/**
	 * Get command line arguments for an event.
	 *
	 * @param event the event
	 * @return command line arguments
	 */
	public String getEventArguments(final Event event) {
<span class="fc" id="L376">		StringBuffer buf = new StringBuffer();</span>

<span class="fc" id="L378">		EventSummary eventSummary = event.getEventSummary();</span>
<span class="fc" id="L379">		buf.append(&quot; &quot;)</span>
<span class="fc" id="L380">				.append(ExternalIndexerListener.PREFERRED_ID_ARGUMENT)</span>
<span class="fc" id="L381">				.append(eventSummary.getId());</span>
<span class="fc" id="L382">		buf.append(&quot; &quot;)</span>
<span class="fc" id="L383">				.append(ExternalIndexerListener.PREFERRED_EVENTSOURCE_ARGUMENT)</span>
<span class="fc" id="L384">				.append(eventSummary.getSource());</span>
<span class="fc" id="L385">		buf.append(&quot; &quot;)</span>
<span class="fc" id="L386">				.append(ExternalIndexerListener.PREFERRED_EVENTSOURCECODE_ARGUMENT)</span>
<span class="fc" id="L387">				.append(eventSummary.getSourceCode());</span>
<span class="fc" id="L388">		Map&lt;String, List&lt;String&gt;&gt; eventids = event.getAllEventCodes(true);</span>
<span class="fc" id="L389">		Iterator&lt;String&gt; sourceIter = eventids.keySet().iterator();</span>
<span class="fc" id="L390">		buf.append(&quot; &quot;).append(EVENT_IDS_ARGUMENT);</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">		while (sourceIter.hasNext()) {</span>
<span class="fc" id="L392">			String source = sourceIter.next();</span>
<span class="fc" id="L393">			Iterator&lt;String&gt; sourceCodeIter = eventids.get(source).iterator();</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">			while (sourceCodeIter.hasNext()) {</span>
<span class="fc" id="L395">				String sourceCode = sourceCodeIter.next();</span>
<span class="fc" id="L396">				buf.append(source).append(sourceCode);</span>
<span class="fc bfc" id="L397" title="All 4 branches covered.">				if (sourceCodeIter.hasNext() || sourceIter.hasNext()) {</span>
<span class="fc" id="L398">					buf.append(&quot;,&quot;);</span>
				}
<span class="fc" id="L400">			}</span>
<span class="fc" id="L401">		}</span>

<span class="fc" id="L403">		buf.append(&quot; &quot;).append(PREFERRED_MAGNITUDE_ARGUMENT)</span>
<span class="fc" id="L404">				.append(eventSummary.getMagnitude());</span>
<span class="fc" id="L405">		buf.append(&quot; &quot;).append(PREFERRED_LATITUDE_ARGUMENT)</span>
<span class="fc" id="L406">				.append(eventSummary.getLatitude());</span>
<span class="fc" id="L407">		buf.append(&quot; &quot;).append(PREFERRED_LONGITUDE_ARGUMENT)</span>
<span class="fc" id="L408">				.append(eventSummary.getLongitude());</span>
<span class="fc" id="L409">		buf.append(&quot; &quot;).append(PREFERRED_DEPTH_ARGUMENT)</span>
<span class="fc" id="L410">				.append(eventSummary.getDepth());</span>
<span class="fc" id="L411">		String eventTime = null;</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">		if (event.getTime() != null) {</span>
<span class="fc" id="L413">			eventTime = XmlUtils.formatDate(event.getTime());</span>
		}
<span class="fc" id="L415">		buf.append(&quot; &quot;).append(PREFERRED_ORIGIN_TIME_ARGUMENT)</span>
<span class="fc" id="L416">				.append(eventTime);</span>

<span class="fc" id="L418">		return buf.toString();</span>
	}

	/**
	 * Get command line arguments for a product summary.
	 *
	 * @param summary the product summary
	 * @return command line arguments
	 * @throws IOException if IO error occurs
	 */
	public String getProductSummaryArguments(final ProductSummary summary) throws IOException {
<span class="fc" id="L429">		StringBuffer buf = new StringBuffer();</span>

<span class="fc" id="L431">		File productDirectory = getStorage().getProductFile(summary.getId());</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">		if (productDirectory.exists()) {</span>
			// Add the directory argument
<span class="fc" id="L434">			buf.append(&quot; &quot;)</span>
<span class="fc" id="L435">					.append(CLIProductBuilder.DIRECTORY_ARGUMENT)</span>
<span class="fc" id="L436">					.append(productDirectory.getCanonicalPath());</span>
		}

		// Add arguments from summary
<span class="fc" id="L440">		buf.append(&quot; &quot;).append(CLIProductBuilder.TYPE_ARGUMENT)</span>
<span class="fc" id="L441">				.append(summary.getType());</span>
<span class="fc" id="L442">		buf.append(&quot; &quot;).append(CLIProductBuilder.CODE_ARGUMENT)</span>
<span class="fc" id="L443">				.append(summary.getCode());</span>
<span class="fc" id="L444">		buf.append(&quot; &quot;).append(CLIProductBuilder.SOURCE_ARGUMENT)</span>
<span class="fc" id="L445">				.append(summary.getSource());</span>
<span class="fc" id="L446">		buf.append(&quot; &quot;)</span>
<span class="fc" id="L447">				.append(CLIProductBuilder.UPDATE_TIME_ARGUMENT)</span>
<span class="fc" id="L448">				.append(XmlUtils.formatDate(summary.getUpdateTime()));</span>
<span class="fc" id="L449">		buf.append(&quot; &quot;).append(CLIProductBuilder.STATUS_ARGUMENT)</span>
<span class="fc" id="L450">				.append(summary.getStatus());</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">		if (summary.isDeleted()) {</span>
<span class="fc" id="L452">			buf.append(&quot; &quot;)</span>
<span class="fc" id="L453">					.append(CLIProductBuilder.DELETE_ARGUMENT);</span>
		}

		// Add optional tracker URL argument
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">		if (summary.getTrackerURL() != null) {</span>
<span class="fc" id="L458">			buf.append(&quot; &quot;)</span>
<span class="fc" id="L459">					.append(CLIProductBuilder.TRACKER_URL_ARGUMENT)</span>
<span class="fc" id="L460">					.append(summary.getTrackerURL());</span>
		}

		// Add property arguments
<span class="fc" id="L464">		Map&lt;String, String&gt; props = summary.getProperties();</span>
<span class="fc" id="L465">		Iterator&lt;String&gt; iter = props.keySet().iterator();</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L467">			String name = iter.next();</span>
<span class="fc" id="L468">			buf.append(&quot; \&quot;&quot;)</span>
<span class="fc" id="L469">					.append(CLIProductBuilder.PROPERTY_ARGUMENT).append(name)</span>
<span class="fc" id="L470">					.append(&quot;=&quot;).append(props.get(name).replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;))</span>
<span class="fc" id="L471">					.append(&quot;\&quot;&quot;);</span>
<span class="fc" id="L472">		}</span>

		// Add link arguments
<span class="fc" id="L475">		Map&lt;String, List&lt;URI&gt;&gt; links = summary.getLinks();</span>
<span class="fc" id="L476">		iter = links.keySet().iterator();</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L478">			String relation = iter.next();</span>
<span class="fc" id="L479">			Iterator&lt;URI&gt; iter2 = links.get(relation).iterator();</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">			while (iter2.hasNext()) {</span>
<span class="fc" id="L481">				buf.append(&quot; &quot;)</span>
<span class="fc" id="L482">						.append(CLIProductBuilder.LINK_ARGUMENT)</span>
<span class="fc" id="L483">						.append(relation).append(&quot;=&quot;)</span>
<span class="fc" id="L484">						.append(iter2.next().toString());</span>
			}
<span class="fc" id="L486">		}</span>

<span class="fc" id="L488">		return buf.toString();</span>
	}

	/**
	 * Configure an ExternalNotificationListener using a Config object.
	 *
	 * @param config
	 *            the config containing a
	 */
	public void configure(Config config) throws Exception {
<span class="nc" id="L498">		super.configure(config);</span>

<span class="nc" id="L500">		command = config.getProperty(COMMAND_PROPERTY);</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">		if (command == null) {</span>
<span class="nc" id="L502">			throw new ConfigurationException(&quot;[&quot; + getName()</span>
					+ &quot;] 'command' is a required configuration property&quot;);
		}
<span class="nc" id="L505">		LOGGER.config(&quot;[&quot; + getName() + &quot;] command is '&quot; + command + &quot;'&quot;);</span>

		// storage references an object in the global configuration
<span class="nc" id="L508">		String storageName = config.getProperty(STORAGE_NAME_PROPERTY);</span>
<span class="nc" id="L509">		String directoryName = config.getProperty(STORAGE_DIRECTORY_PROPERTY);</span>
<span class="nc bnc" id="L510" title="All 4 branches missed.">		if (storageName == null &amp;&amp; directoryName == null) {</span>
<span class="nc" id="L511">			throw new ConfigurationException(&quot;[&quot; + getName()</span>
					+ &quot;] one of 'storage' or 'storageDirectory' is required&quot;);
		}

<span class="nc bnc" id="L515" title="All 2 branches missed.">		if (storageName != null) {</span>
<span class="nc" id="L516">			LOGGER.config(&quot;[&quot; + getName() + &quot;] loading FileProductStorage '&quot;</span>
					+ storageName + &quot;'&quot;);
<span class="nc" id="L518">			storage = (FileProductStorage) Config.getConfig().getObject(</span>
					storageName);
<span class="nc bnc" id="L520" title="All 2 branches missed.">			if (storage == null) {</span>
<span class="nc" id="L521">				throw new ConfigurationException(&quot;[&quot; + getName()</span>
						+ &quot;] unable to load FileProductStorage '&quot; + storageName
						+ &quot;'&quot;);
			}
		} else {
<span class="nc" id="L526">			LOGGER.config(&quot;[&quot; + getName() + &quot;] using storage directory '&quot;</span>
					+ directoryName + &quot;'&quot;);
<span class="nc" id="L528">			storage = new FileProductStorage(new File(directoryName));</span>
<span class="nc" id="L529">			storage.setName(getName() + &quot;-storage&quot;);</span>
		}

<span class="nc" id="L532">		autoArchive = Boolean.valueOf(config.getProperty(AUTO_ARCHIVE_PROPERTY,</span>
				AUTO_ARCHIVE_DEFAULT));
<span class="nc" id="L534">		LOGGER.config(&quot;[&quot; + getName() + &quot;] autoArchive = &quot; + autoArchive);</span>
<span class="nc" id="L535">	}</span>

	/**
	 * Called when client is shutting down.
	 */
	public void shutdown() throws Exception {
<span class="fc" id="L541">		super.shutdown();</span>
		// maybe make current process a member and kill process?
		// or find way of detaching so client process can exit but product
		// process can complete?
<span class="fc" id="L545">		storage.shutdown();</span>
<span class="fc" id="L546">	}</span>

	/**
	 * Called after client has been configured and should begin processing.
	 */
	public void startup() throws Exception {
		// no background threads to start or objects to create
<span class="fc" id="L553">		storage.startup();</span>
<span class="fc" id="L554">		super.startup();</span>
<span class="fc" id="L555">	}</span>

	/**
	 * @return the storage
	 */
	public FileProductStorage getStorage() {
<span class="fc" id="L561">		return storage;</span>
	}

	/**
	 * @param storage
	 *            the storage to set
	 */
	public void setStorage(FileProductStorage storage) {
<span class="fc" id="L569">		this.storage = storage;</span>
<span class="fc" id="L570">	}</span>

	/**
	 * @return the command
	 */
	public String getCommand() {
<span class="fc" id="L576">		return command;</span>
	}

	/**
	 * @param command
	 *            the command to set
	 */
	public void setCommand(String command) {
<span class="fc" id="L584">		this.command = command;</span>
<span class="fc" id="L585">	}</span>

	/**
	 * @return the autoArchive
	 */
	public boolean isAutoArchive() {
<span class="nc" id="L591">		return autoArchive;</span>
	}

	/**
	 * @param autoArchive
	 *            the autoArchive to set
	 */
	public void setAutoArchive(boolean autoArchive) {
<span class="nc" id="L599">		this.autoArchive = autoArchive;</span>
<span class="nc" id="L600">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>