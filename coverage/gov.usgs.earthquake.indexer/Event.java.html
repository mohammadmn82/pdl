<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Event.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.earthquake.indexer</a> &gt; <span class="el_source">Event.java</span></div><h1>Event.java</h1><pre class="source lang-java linenums">/*
 * Event
 */
package gov.usgs.earthquake.indexer;

import gov.usgs.earthquake.product.ProductId;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * An event is a group of products that are nearby in space and time.
 *
 * Which products appear in an event depend primarily on the
 * ProductIndexQuery.ResultType that is used when retrieving an event from the
 * index. Unless CURRENT is used, you may not get what you expect.
 */
public class Event implements Comparable&lt;Event&gt; {

	/** Origin product type */
	public static final String ORIGIN_PRODUCT_TYPE = &quot;origin&quot;;
	/** Associate product type */
	public static final String ASSOCIATE_PRODUCT_TYPE = &quot;associate&quot;;
	/** Disassociate product type */
	public static final String DISASSOCIATE_PRODUCT_TYPE = &quot;disassociate&quot;;
	/** Property for othereventsource */
	public static final String OTHEREVENTSOURCE_PROPERTY = &quot;othereventsource&quot;;
	/** Property for othereventsourcecode */
	public static final String OTHEREVENTSOURCECODE_PROPERTY = &quot;othereventsourcecode&quot;;

	/** An ID used by the ProductIndex. */
<span class="pc" id="L43">	private Long indexId = null;</span>

	/** Products nearby in space and time. Keyed by type. */
<span class="pc" id="L46">	private Map&lt;String, List&lt;ProductSummary&gt;&gt; products = new HashMap&lt;String, List&lt;ProductSummary&gt;&gt;();</span>

	/** Cached summary. */
<span class="pc" id="L49">	private EventSummary eventSummary = null;</span>

	/**
	 * Default constructor.
	 *
	 * All fields are set to null, and the list of products is empty.
	 */
<span class="fc" id="L56">	public Event() {</span>
<span class="fc" id="L57">	}</span>

	/**
	 * Construct an event with only an indexId. The products map will be empty.
	 *
	 * @param indexId
	 *            the indexId to set.
	 */
<span class="nc" id="L65">	public Event(final Long indexId) {</span>
<span class="nc" id="L66">		this.setIndexId(indexId);</span>
<span class="nc" id="L67">	}</span>

	/**
	 * Construct and event with an indexId and a list of products.
	 *
	 * @param indexId
	 *            the product index id.
	 * @param products
	 *            the list of products.
	 */
	public Event(final Long indexId,
<span class="fc" id="L78">			final Map&lt;String, List&lt;ProductSummary&gt;&gt; products) {</span>
<span class="fc" id="L79">		this.setIndexId(indexId);</span>
<span class="fc" id="L80">		this.setProducts(products);</span>
<span class="fc" id="L81">	}</span>

	/**
	 * Copy constructor for event.
	 *
	 * The products associated with this event are not cloned, but the list of
	 * products is.
	 *
	 * @param copy
	 *            the event to clone.
	 */
	public Event(final Event copy) {
<span class="fc" id="L93">		this(copy.getIndexId(), copy.getAllProducts());</span>
<span class="fc" id="L94">	}</span>

	/**
	 * Get the index id.
	 *
	 * @return the indexId or null if one hasn't been assigned.
	 */
	public Long getIndexId() {
<span class="fc" id="L102">		return indexId;</span>
	}

	/**
	 * Set the index id.
	 *
	 * @param indexId
	 *            the indexId to set.
	 */
	public void setIndexId(Long indexId) {
<span class="fc" id="L112">		this.indexId = indexId;</span>
<span class="fc" id="L113">	}</span>

	/**
	 * Get all products associated with event, even if they are deleted.
	 *
	 * @return all products associated with event.
	 */
	public Map&lt;String, List&lt;ProductSummary&gt;&gt; getAllProducts() {
<span class="fc" id="L121">		return products;</span>
	}

	/**
	 * Get the event products.
	 *
	 * Only returns products that have not been deleted or superseded. This
	 * method returns a copy of the underlying product map that has been
	 * filtered to remove deleted products.
	 *
	 * @return a map of event products.
	 * @see #getAllProducts()
	 */
	public Map&lt;String, List&lt;ProductSummary&gt;&gt; getProducts() {
<span class="fc" id="L135">		Map&lt;String, List&lt;ProductSummary&gt;&gt; notDeleted = new HashMap&lt;String, List&lt;ProductSummary&gt;&gt;();</span>
<span class="fc" id="L136">		Iterator&lt;String&gt; types = products.keySet().iterator();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">		while (types.hasNext()) {</span>
<span class="fc" id="L138">			String type = types.next();</span>
<span class="fc" id="L139">			List&lt;ProductSummary&gt; notDeletedProducts = getProducts(type);</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">			if (notDeletedProducts.size() &gt; 0) {</span>
<span class="fc" id="L141">				notDeleted.put(type, notDeletedProducts);</span>
			}
<span class="fc" id="L143">		}</span>
<span class="fc" id="L144">		return notDeleted;</span>
	}

	/**
	 * Set products.
	 *
	 * ProductSummaries are not cloned, but lists are.
	 *
	 * @param newProducts
	 *            the products to set.
	 */
	public void setProducts(final Map&lt;String, List&lt;ProductSummary&gt;&gt; newProducts) {
<span class="fc" id="L156">		this.products.clear();</span>
<span class="fc" id="L157">		Iterator&lt;String&gt; iter = new TreeSet&lt;String&gt;(newProducts.keySet())</span>
<span class="fc" id="L158">				.iterator();</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L160">			String type = iter.next();</span>
<span class="fc" id="L161">			this.products.put(type,</span>
<span class="fc" id="L162">					new ArrayList&lt;ProductSummary&gt;(newProducts.get(type)));</span>
<span class="fc" id="L163">		}</span>
<span class="fc" id="L164">		eventSummary = null;</span>
<span class="fc" id="L165">	}</span>

	/**
	 * A convenience method for adding a product summary to an event object.
	 *
	 * Note: this method does not update any associated product index.
	 *
	 * @param summary
	 *            the summary to add to this event.
	 */
	public void addProduct(final ProductSummary summary) {
<span class="fc" id="L176">		String type = summary.getId().getType();</span>
<span class="fc" id="L177">		List&lt;ProductSummary&gt; list = products.get(type);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">		if (list == null) {</span>
<span class="fc" id="L179">			list = new ArrayList&lt;ProductSummary&gt;();</span>
<span class="fc" id="L180">			products.put(type, list);</span>
		}
<span class="fc bfc" id="L182" title="All 2 branches covered.">		if (!list.contains(summary)) {</span>
<span class="fc" id="L183">			list.add(summary);</span>
		}
<span class="fc" id="L185">		eventSummary = null;</span>
<span class="fc" id="L186">	}</span>

	/**
	 * A convenience method for removing a product summary from an event object.
	 *
	 * Note: this method does not update any associated product index.
	 *
	 * @param summary
	 *            the summary to remove from this event.
	 */
	public void removeProduct(final ProductSummary summary) {
<span class="nc" id="L197">		String type = summary.getId().getType();</span>
		// find the list of products of this type
<span class="nc" id="L199">		List&lt;ProductSummary&gt; list = products.get(type);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">		if (list != null) {</span>
			// remove the product from the list
<span class="nc" id="L202">			list.remove(summary);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">			if (list.size() == 0) {</span>
				// if the list is now empty, remove the list
<span class="nc" id="L205">				products.remove(type);</span>
			}
		}
<span class="nc" id="L208">		eventSummary = null;</span>
<span class="nc" id="L209">	}</span>

	/**
	 * Convenience method to get products of a given type.
	 *
	 * This method always returns a copy of the internal list, and may be empty.
	 * Only returns products that have not been deleted or superseded.
	 *
	 * @param type
	 *            the product type.
	 * @return a list of products of that type, which may be empty.
	 */
	public List&lt;ProductSummary&gt; getProducts(final String type) {
<span class="fc" id="L222">		ArrayList&lt;ProductSummary&gt; typeProducts = new ArrayList&lt;ProductSummary&gt;();</span>

<span class="fc bfc" id="L224" title="All 2 branches covered.">		if (products.containsKey(type)) {</span>
			// only return products that haven't been deleted
<span class="fc" id="L226">			typeProducts.addAll(getWithoutDeleted(getWithoutSuperseded(products</span>
<span class="fc" id="L227">					.get(type))));</span>
		}

<span class="fc" id="L230">		return typeProducts;</span>
	}

	/**
	 * Get all event products (including those that are deleted or superseded).
	 *
	 * @return a list of event products.
	 */
	public List&lt;ProductSummary&gt; getAllProductList() {
<span class="fc" id="L239">		List&lt;ProductSummary&gt; allProductList = new ArrayList&lt;ProductSummary&gt;();</span>
<span class="fc" id="L240">		Map&lt;String, List&lt;ProductSummary&gt;&gt; allProducts = getAllProducts();</span>
<span class="fc" id="L241">		Iterator&lt;String&gt; iter = allProducts.keySet().iterator();</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L243">			allProductList.addAll(allProducts.get(iter.next()));</span>
		}
<span class="fc" id="L245">		return allProductList;</span>
	}

	/**
	 * Get all event products that have not been deleted or superseded as a
	 * list.
	 *
	 * @return a list of event products.
	 */
	public List&lt;ProductSummary&gt; getProductList() {
<span class="fc" id="L255">		List&lt;ProductSummary&gt; productList = new ArrayList&lt;ProductSummary&gt;();</span>
<span class="fc" id="L256">		Map&lt;String, List&lt;ProductSummary&gt;&gt; notDeletedProducts = getProducts();</span>
<span class="fc" id="L257">		Iterator&lt;String&gt; iter = notDeletedProducts.keySet().iterator();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L259">			productList.addAll(notDeletedProducts.get(iter.next()));</span>
		}
<span class="fc" id="L261">		return productList;</span>
	}

	/**
	 * Get preferred products of all types.
	 *
	 * This map will contain one product of each type, chosen by preferred
	 * weight.
	 *
	 * @return a map from product type to the preferred product of that type.
	 */
	public Map&lt;String, ProductSummary&gt; getPreferredProducts() {
<span class="nc" id="L273">		Map&lt;String, ProductSummary&gt; preferredProducts = new HashMap&lt;String, ProductSummary&gt;();</span>

<span class="nc" id="L275">		Map&lt;String, List&lt;ProductSummary&gt;&gt; notDeletedProducts = getProducts();</span>
<span class="nc" id="L276">		Iterator&lt;String&gt; types = notDeletedProducts.keySet().iterator();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">		while (types.hasNext()) {</span>
<span class="nc" id="L278">			String type = types.next();</span>
<span class="nc" id="L279">			preferredProducts.put(type,</span>
<span class="nc" id="L280">					getPreferredProduct(notDeletedProducts.get(type)));</span>
<span class="nc" id="L281">		}</span>

<span class="nc" id="L283">		return preferredProducts;</span>
	}

	/**
	 * Get the preferred product of a specific type.
	 *
	 * @param type
	 *            type of product to get.
	 * @return most preferred product of that type, or null if no product of
	 *         that type is associated.
	 */
	public ProductSummary getPreferredProduct(final String type) {
<span class="fc" id="L295">		return getPreferredProduct(getProducts(type));</span>
	}

	/**
	 * Get a map of all event ids associated with this event.
	 *
	 * Same as Event.getEventCodes(this.getAllProductList());
	 *
	 * @deprecated use {@link #getAllEventCodes(boolean)} instead.
	 * @return map of all event ids associated with this event.
	 */
	public Map&lt;String, String&gt; getEventCodes() {
<span class="fc" id="L307">		return getEventCodes(this.getAllProductList());</span>
	}

	/**
	 * Get a map of all event ids associated with this event.
	 *
	 * Map key is eventSource, Map value is eventSourceCode.
	 *
	 * @deprecated use {@link #getAllEventCodes(boolean)} instead.
	 * @param summaries
	 *            the summaries list to extract event codes from.
	 * @return map of all event ids associated with this event.
	 */
	public static Map&lt;String, String&gt; getEventCodes(
			final List&lt;ProductSummary&gt; summaries) {
<span class="fc" id="L322">		Map&lt;String, String&gt; eventIds = new HashMap&lt;String, String&gt;();</span>
		// order most preferred last,
		// to minimize impact of multiple codes from same source
<span class="fc" id="L325">		List&lt;ProductSummary&gt; sorted = getSortedMostPreferredFirst(</span>
<span class="fc" id="L326">				getWithoutSuperseded(summaries));</span>
<span class="fc" id="L327">		Collections.reverse(sorted);</span>
		// done ordering
<span class="fc" id="L329">		Iterator&lt;ProductSummary&gt; iter = sorted.iterator();</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L331">			ProductSummary product = iter.next();</span>
<span class="fc" id="L332">			String source = product.getEventSource();</span>
<span class="fc" id="L333">			String code = product.getEventSourceCode();</span>
<span class="pc bpc" id="L334" title="1 of 4 branches missed.">			if (source != null &amp;&amp; code != null) {</span>
<span class="fc" id="L335">				eventIds.put(source.toLowerCase(), code.toLowerCase());</span>
			}
<span class="fc" id="L337">		}</span>
<span class="fc" id="L338">		return eventIds;</span>
	}

	/**
	 * Get a map of all event ids associated with this event, recognizing that
	 * one source may have multiple codes (they broke the rules, but it
	 * happens).
	 *
	 * @param includeDeleted
	 *            whether to include ids for sub events whose products have all
	 *            been deleted.
	 * @return Map from source to a list of codes from that source.
	 */
	public Map&lt;String, List&lt;String&gt;&gt; getAllEventCodes(
			final boolean includeDeleted) {
<span class="fc" id="L353">		Map&lt;String, List&lt;String&gt;&gt; allEventCodes = new HashMap&lt;String, List&lt;String&gt;&gt;();</span>

<span class="fc" id="L355">		Map&lt;String, Event&gt; subEvents = getSubEvents();</span>
<span class="fc" id="L356">		Iterator&lt;String&gt; iter = subEvents.keySet().iterator();</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L358">			Event subEvent = subEvents.get(iter.next());</span>
<span class="fc bfc" id="L359" title="All 4 branches covered.">			if (!includeDeleted &amp;&amp; subEvent.isDeleted()) {</span>
				// check for non-deleted products that should
				// keep the event code alive
<span class="fc" id="L362">				List&lt;ProductSummary&gt; nonDeletedProducts = getWithoutDeleted(</span>
<span class="fc" id="L363">						getWithoutSuperseded(subEvent.getAllProductList()));</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">				if (nonDeletedProducts.size() == 0) {</span>
					// filter deleted events
<span class="fc" id="L366">					continue;</span>
				}
				// otherwise, event has active products;
				// prevent same source associations
			}

			// add code to list for source
<span class="fc" id="L373">			String source = subEvent.getSource();</span>
<span class="fc" id="L374">			String sourceCode = subEvent.getSourceCode();</span>
<span class="fc" id="L375">			List&lt;String&gt; sourceEventCodes = allEventCodes.get(source);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">			if (sourceEventCodes == null) {</span>
				// create list for source
<span class="fc" id="L378">				sourceEventCodes = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L379">				allEventCodes.put(source, sourceEventCodes);</span>
			}
			// keep list distinct
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">			if (!sourceEventCodes.contains(sourceCode)) {</span>
<span class="fc" id="L383">				sourceEventCodes.add(sourceCode);</span>
			}
<span class="fc" id="L385">		}</span>

<span class="fc" id="L387">		return allEventCodes;</span>
	}

	/**
	 * Get a list of all the preferred products sorted based on their
	 * authoritative weights
	 *
	 * @return sorted list of ProductSummary objects
	 */
	public List&lt;ProductSummary&gt; getPreferredProductsSorted() {
<span class="nc" id="L397">		Map&lt;String, ProductSummary&gt; preferred = getPreferredProducts();</span>

		// Transform the preferred HashMap into a List so we can sort based on
		// preferred weight
<span class="nc" id="L401">		List&lt;ProductSummary&gt; productList = new ArrayList&lt;ProductSummary&gt;(preferred.values());</span>

		// Sort the list, then iterate through it until we find the specified
		// property
<span class="nc" id="L405">		Collections.sort(productList, new MostPreferredFirstComparator());</span>
<span class="nc" id="L406">		return productList;</span>
	}

	/**
	 * Get the event id.
	 *
	 * The event id is the combination of event source and event source code.
	 *
	 * @return the event id, or null if either event source or event source code
	 *         is null.
	 * @see #getSource()
	 * @see #getSourceCode()
	 */
	public String getEventId() {
<span class="fc" id="L420">		ProductSummary product = getEventIdProduct();</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">		if (product != null) {</span>
<span class="fc" id="L422">			return product.getEventId();</span>
		}
<span class="nc" id="L424">		return null;</span>
	}

	/**
	 * Get the preferred source for this event. If an origin product exists,
	 * it's value is used.
	 *
	 * @return Source from preferred product or null
	 */
	public String getSource() {
<span class="fc" id="L434">		ProductSummary product = getEventIdProduct();</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">		if (product != null) {</span>
<span class="fc" id="L436">			return product.getEventSource();</span>
		}
<span class="fc" id="L438">		return null;</span>
	}

	/**
	 * Get the preferred source code for this event. If an origin product
	 * exists, it's value is used.
	 *
	 * @return Source code from preferred product or null
	 */
	public String getSourceCode() {
<span class="fc" id="L448">		ProductSummary product = getEventIdProduct();</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">		if (product != null) {</span>
<span class="fc" id="L450">			return product.getEventSourceCode();</span>
		}
<span class="fc" id="L452">		return null;</span>
	}

	/**
	 * Get the product used for eventsource and eventsourcecode.
	 *
	 * Event ID comes from the preferred origin product.
	 *
	 * @return The most preferred product summary. This summary is used to
	 *         determine the eventsouce and eventsourcecode.
	 * @see #getPreferredOriginProduct()
	 */
	protected ProductSummary getEventIdProduct() {
<span class="fc" id="L465">		ProductSummary product = getPreferredOriginProduct();</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">		if (product == null) {</span>
<span class="fc" id="L467">			product = getProductWithOriginProperties();</span>
		}
<span class="fc" id="L469">		return product;</span>
	}

	/**
	 * Get the most recent product with origin properties (id, lat, lon, time).
	 *
	 * &lt;strong&gt;NOTE&lt;/strong&gt;: this product may have been superseded by a delete.
	 * When an event has not been deleted, this method should be consistent with
	 *  {@link #getPreferredOriginProduct()}.
	 *
	 * Products are checked in the following order, sorted most preferred first
	 * within each group.  The first matching product is returned:
	 * &lt;ol&gt;
	 * &lt;li&gt;&quot;origin&quot; products not superseded or deleted,
	 * 		that have origin properties&lt;/li&gt;
	 * &lt;li&gt;&quot;origin&quot; products superseded by a delete,
	 * 		that have origin properties&lt;/li&gt;
	 * &lt;li&gt;products not superseded or deleted,
	 * 		that have origin properties&lt;/li&gt;
	 * &lt;li&gt;products superseded by a delete,
	 * 		that have origin properties&lt;/li&gt;
	 * &lt;/ol&gt;
	 *
	 * @return the most recent product with origin properties.
	 * @see #productHasOriginProperties(ProductSummary)
	 */
	public ProductSummary getProductWithOriginProperties() {
<span class="fc" id="L496">		Map&lt;String, List&lt;ProductSummary&gt;&gt; allProducts = getAllProducts();</span>
<span class="fc" id="L497">		List&lt;ProductSummary&gt; productsList = null;</span>
<span class="fc" id="L498">		ProductSummary preferredProduct = null;</span>
<span class="fc" id="L499">		Iterator&lt;ProductSummary&gt; iter = null;</span>

<span class="fc" id="L501">		productsList = allProducts.get(ORIGIN_PRODUCT_TYPE);</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">		if (productsList != null) {</span>
			// &quot;origin&quot; products not superseded or deleted
<span class="fc" id="L504">			productsList = getSortedMostPreferredFirst(getWithoutDeleted(</span>
<span class="fc" id="L505">					getWithoutSuperseded(allProducts.get(ORIGIN_PRODUCT_TYPE))));</span>
<span class="fc" id="L506">			iter = productsList.iterator();</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">			while (iter.hasNext()) {</span>
<span class="fc" id="L508">				preferredProduct = iter.next();</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">				if (productHasOriginProperties(preferredProduct)) {</span>
<span class="fc" id="L510">					return preferredProduct;</span>
				}
			}

			// &quot;origin&quot; products superseded by a delete
<span class="fc" id="L515">			productsList = getSortedMostPreferredFirst(getWithoutSuperseded(</span>
<span class="fc" id="L516">					getWithoutDeleted(allProducts.get(ORIGIN_PRODUCT_TYPE))));</span>
<span class="fc" id="L517">			iter = productsList.iterator();</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">			while (iter.hasNext()) {</span>
<span class="fc" id="L519">				preferredProduct = iter.next();</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">				if (productHasOriginProperties(preferredProduct)) {</span>
<span class="fc" id="L521">					return preferredProduct;</span>
				}
			}
		}

		// products not superseded or deleted
<span class="fc" id="L527">		productsList = getSortedMostPreferredFirst(getWithoutDeleted(</span>
<span class="fc" id="L528">				getWithoutSuperseded(productTypeMapToList(allProducts))));</span>
<span class="fc" id="L529">		iter = productsList.iterator();</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L531">			preferredProduct = iter.next();</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">			if (productHasOriginProperties(preferredProduct)) {</span>
<span class="fc" id="L533">				return preferredProduct;</span>
			}
		}

		// products superseded by a delete
<span class="fc" id="L538">		productsList = getSortedMostPreferredFirst(getWithoutSuperseded(</span>
<span class="fc" id="L539">				getWithoutDeleted(productTypeMapToList(allProducts))));</span>
<span class="fc" id="L540">		iter = productsList.iterator();</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L542">			preferredProduct = iter.next();</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">			if (productHasOriginProperties(preferredProduct)) {</span>
<span class="fc" id="L544">				return preferredProduct;</span>
			}
		}

<span class="fc" id="L548">		return null;</span>
	}

	/**
	 * Get the most preferred origin-like product for this event.
	 *
	 * The event is considered deleted if the returned product is null, deleted,
	 * or does not have origin properties.  Information about the event
	 * may still be available using {@link #getProductWithOriginProperties()}.
	 *
	 * Products are checked in the following order, sorted most preferred first
	 * within each group.  The first matching product is returned:
	 * &lt;ul&gt;
	 * &lt;li&gt;If any &quot;origin&quot; products exist:
	 * 		&lt;ol&gt;
	 * 		&lt;li&gt;&quot;origin&quot; products not superseded or deleted,
	 * 				that have origin properties.&lt;/li&gt;
	 * 		&lt;li&gt;&quot;origin&quot; products not superseded,
	 * 				that have an event id.&lt;/li&gt;
	 * 		&lt;/ol&gt;
	 * &lt;/li&gt;
	 * &lt;li&gt;If no &quot;origin&quot; products exist:
	 * 		&lt;ol&gt;
	 * 		&lt;li&gt;products not superseded or deleted,
	 * 				that have origin properties.&lt;/li&gt;
	 * 		&lt;li&gt;products not superseded,
	 * 				that have an event id.&lt;/li&gt;
	 * 		&lt;/ol&gt;
	 * &lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * @return the most recent product with origin properties.
	 * @see #productHasOriginProperties(ProductSummary)
	 */
	public ProductSummary getPreferredOriginProduct() {
<span class="fc" id="L583">		Map&lt;String, List&lt;ProductSummary&gt;&gt; allProducts = getAllProducts();</span>
<span class="fc" id="L584">		List&lt;ProductSummary&gt; productsList = null;</span>
<span class="fc" id="L585">		ProductSummary preferredProduct = null;</span>
<span class="fc" id="L586">		Iterator&lt;ProductSummary&gt; iter = null;</span>

<span class="fc" id="L588">		productsList = allProducts.get(ORIGIN_PRODUCT_TYPE);</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">		if (productsList != null) {</span>
			// &quot;origin&quot; products not superseded or deleted,
			// that have origin properties
<span class="fc" id="L592">			productsList = getSortedMostPreferredFirst(getWithoutDeleted(</span>
<span class="fc" id="L593">					getWithoutSuperseded(allProducts.get(ORIGIN_PRODUCT_TYPE))));</span>
<span class="fc" id="L594">			iter = productsList.iterator();</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">			while (iter.hasNext()) {</span>
<span class="fc" id="L596">				preferredProduct = iter.next();</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">				if (productHasOriginProperties(preferredProduct)) {</span>
<span class="fc" id="L598">					return preferredProduct;</span>
				}
			}

			// &quot;origin&quot; products not superseded,
			// that have event id
<span class="fc" id="L604">			productsList = getSortedMostPreferredFirst(getWithoutSuperseded(</span>
<span class="fc" id="L605">					allProducts.get(ORIGIN_PRODUCT_TYPE)));</span>
<span class="fc" id="L606">			iter = productsList.iterator();</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">			while (iter.hasNext()) {</span>
<span class="fc" id="L608">				preferredProduct = iter.next();</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">				if (preferredProduct.getEventSource() != null</span>
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">						&amp;&amp; preferredProduct.getEventSourceCode() != null) {</span>
<span class="fc" id="L611">					return preferredProduct;</span>
				}
			}

<span class="nc" id="L615">			return null;</span>
		}

		// products not superseded or deleted,
		// that have origin properties
<span class="fc" id="L620">		productsList = getSortedMostPreferredFirst(getWithoutDeleted(</span>
<span class="fc" id="L621">				getWithoutSuperseded(productTypeMapToList(allProducts))));</span>
<span class="fc" id="L622">		iter = productsList.iterator();</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L624">			preferredProduct = iter.next();</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">			if (productHasOriginProperties(preferredProduct)) {</span>
<span class="fc" id="L626">				return preferredProduct;</span>
			}
		}

		// products not superseded,
		// that have event id
<span class="fc" id="L632">		productsList = getSortedMostPreferredFirst(getWithoutSuperseded(</span>
<span class="fc" id="L633">				productTypeMapToList(allProducts)));</span>
<span class="fc" id="L634">		iter = productsList.iterator();</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L636">			preferredProduct = iter.next();</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">			if (preferredProduct.getEventSource() != null</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">					&amp;&amp; preferredProduct.getEventSourceCode() != null) {</span>
<span class="fc" id="L639">				return preferredProduct;</span>
			}
		}

<span class="fc" id="L643">		return null;</span>
	}

	/**
	 * Check if a product can define an event (id, lat, lon, time).
	 *
	 * @param product
	 *            product to check.
	 * @return true if product has id, lat, lon, and time properties.
	 */
	public static boolean productHasOriginProperties(
			final ProductSummary product) {
<span class="fc bfc" id="L655" title="All 2 branches covered.">		return (product.getEventSource() != null</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">				&amp;&amp; product.getEventSourceCode() != null</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">				&amp;&amp; product.getEventLatitude() != null</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">				&amp;&amp; product.getEventLongitude() != null &amp;&amp; product</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">					.getEventTime() != null);</span>
	}

	/**
	 * Get the most preferred magnitude product for event.
	 *
	 * Currently calls {@link #getPreferredOriginProduct()}.
	 *
	 * @return the most preferred magnitude product for event.
	 */
	public ProductSummary getPreferredMagnitudeProduct() {
<span class="fc" id="L670">		return getPreferredOriginProduct();</span>
	}

	/**
	 * Get the preferred time for this event. If an origin product exists, it's
	 * value is used.
	 *
	 * @return Time from preferred product or null
	 */
	public Date getTime() {
<span class="fc" id="L680">		ProductSummary preferred = getProductWithOriginProperties();</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">		if (preferred != null) {</span>
<span class="fc" id="L682">			return preferred.getEventTime();</span>
		}
<span class="fc" id="L684">		return null;</span>
	}

	/**
	 * Get the preferred latitude for this event. If an origin product exists,
	 * it's value is used.
	 *
	 * @return Latitude from preferred product or null
	 */
	public BigDecimal getLatitude() {
<span class="fc" id="L694">		ProductSummary preferred = getProductWithOriginProperties();</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">		if (preferred != null) {</span>
<span class="fc" id="L696">			return preferred.getEventLatitude();</span>
		}
<span class="fc" id="L698">		return null;</span>

	}

	/**
	 * Get the preferred longitude for this event. If an origin product exists,
	 * it's value is used.
	 *
	 * @return Longitude from preferred product or null
	 */
	public BigDecimal getLongitude() {
<span class="fc" id="L709">		ProductSummary preferred = getProductWithOriginProperties();</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">		if (preferred != null) {</span>
<span class="fc" id="L711">			return preferred.getEventLongitude();</span>
		}
<span class="fc" id="L713">		return null;</span>

	}

	/**
	 * Event update time is most recent product update time.
	 *
	 * @return the most recent product update time.
	 */
	public Date getUpdateTime() {
<span class="nc" id="L723">		Date updateTime = null;</span>
<span class="nc" id="L724">		Date time = null;</span>
<span class="nc" id="L725">		Iterator&lt;ProductSummary&gt; iter = getAllProductList().iterator();</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">		while (iter.hasNext()) {</span>
<span class="nc" id="L727">			time = iter.next().getId().getUpdateTime();</span>
<span class="nc bnc" id="L728" title="All 4 branches missed.">			if (updateTime == null || time.after(updateTime)) {</span>
<span class="nc" id="L729">				time = updateTime;</span>
			}
		}
<span class="nc" id="L732">		return updateTime;</span>
	}

	/**
	 * Get the preferred depth for this event. If an origin product exists, it's
	 * value is used.
	 *
	 * @return Depth from preferred product or null
	 */
	public BigDecimal getDepth() {
<span class="fc" id="L742">		ProductSummary preferred = getProductWithOriginProperties();</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">		if (preferred != null) {</span>
<span class="fc" id="L744">			return preferred.getEventDepth();</span>
		}
<span class="fc" id="L746">		return null;</span>
	}

	/**
	 * Get the preferred magntitude for this event. If an origin product exists, it's
	 * value is used.
	 *
	 * @return magnitude from preferred product or null
	 */
	public BigDecimal getMagnitude() {
<span class="fc" id="L756">		ProductSummary preferred = getPreferredMagnitudeProduct();</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">		if (preferred != null) {</span>
<span class="fc" id="L758">			return preferred.getEventMagnitude();</span>
		}
<span class="fc" id="L760">		return null;</span>
	}

	/**
	 * @return boolean if the preferred event is deleted
	 */
	public boolean isDeleted() {
<span class="fc" id="L767">		ProductSummary preferred = getPreferredOriginProduct();</span>
<span class="fc bfc" id="L768" title="All 4 branches covered.">		if (preferred != null &amp;&amp; !preferred.isDeleted() &amp;&amp;</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">				Event.productHasOriginProperties(preferred)) {</span>
			// have &quot;origin&quot; type product, that isn't deleted,
			// and has origin properties
<span class="fc" id="L772">			return false;</span>
		}
		// otherwise, deleted
<span class="fc" id="L775">		return true;</span>
	}

	/**
	 * Get the most preferred product from a list of products.
	 *
	 * @param all
	 *            a list of products containing only one type of product.
	 * @return the product with the highest preferred weight, and if tied the
	 *         most recent update time wins.
	 */
	public static ProductSummary getPreferredProduct(
			final List&lt;ProductSummary&gt; all) {
<span class="fc" id="L788">		ProductSummary preferred = null;</span>

<span class="fc" id="L790">		Iterator&lt;ProductSummary&gt; iter = all.iterator();</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L792">			ProductSummary summary = iter.next();</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">			if (preferred == null) {</span>
<span class="fc" id="L794">				preferred = summary;</span>
			} else {
<span class="fc" id="L796">				long summaryWeight = summary.getPreferredWeight();</span>
<span class="fc" id="L797">				long preferredWeight = preferred.getPreferredWeight();</span>
<span class="fc bfc" id="L798" title="All 4 branches covered.">				if (summaryWeight &gt; preferredWeight</span>
<span class="fc" id="L799">						|| (summaryWeight == preferredWeight &amp;&amp; summary.getId()</span>
<span class="fc" id="L800">								.getUpdateTime()</span>
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">								.after(preferred.getId().getUpdateTime()))) {</span>
<span class="fc" id="L802">					preferred = summary;</span>
				}
			}
<span class="fc" id="L805">		}</span>
<span class="fc" id="L806">		return preferred;</span>
	}

	/**
	 * Summarize this event into preferred values.
	 *
	 * NOTE: the event summary may include information from an origin product,
	 * even when the preferred origin for the event has been deleted.  Use
	 * getPreferredOriginProduct() to check the preferred origin of the event.
	 *
	 * @return an event summary.
	 */
	public EventSummary getEventSummary() {
<span class="fc bfc" id="L819" title="All 2 branches covered.">		if (eventSummary != null) {</span>
<span class="fc" id="L820">			return eventSummary;</span>
		}

<span class="fc" id="L823">		EventSummary summary = new EventSummary();</span>
<span class="fc" id="L824">		summary.setIndexId(this.getIndexId());</span>
<span class="fc" id="L825">		summary.setDeleted(this.isDeleted());</span>

<span class="fc" id="L827">		ProductSummary eventIdProduct = this.getEventIdProduct();</span>
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">		if (eventIdProduct != null) {</span>
<span class="fc" id="L829">			summary.setSource(eventIdProduct.getEventSource());</span>
<span class="fc" id="L830">			summary.setSourceCode(eventIdProduct.getEventSourceCode());</span>
		}

<span class="fc" id="L833">		ProductSummary originProduct = this.getProductWithOriginProperties();</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">		if (originProduct != null) {</span>
<span class="fc" id="L835">			summary.setLatitude(originProduct.getEventLatitude());</span>
<span class="fc" id="L836">			summary.setLongitude(originProduct.getEventLongitude());</span>
<span class="fc" id="L837">			summary.setTime(originProduct.getEventTime());</span>
<span class="fc" id="L838">			summary.setDepth(originProduct.getEventDepth());</span>
		}

<span class="fc" id="L841">		ProductSummary magnitudeProduct = this.getPreferredMagnitudeProduct();</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">		if (magnitudeProduct != null) {</span>
<span class="fc" id="L843">			summary.setMagnitude(magnitudeProduct.getEventMagnitude());</span>
		}

		// we may be able to avoid implementing this here, since the mapping
		// interface will be driven by the PHP product index.
<span class="fc" id="L848">		summary.getEventCodes().putAll(this.getEventCodes());</span>

		// cache summary
<span class="fc" id="L851">		eventSummary = summary;</span>

<span class="fc" id="L853">		return summary;</span>
	}

	/**
	 * Comparison class that compares two ProductSummary objects based on their
	 * preferred weight and update time.
	 *
	 */
<span class="fc" id="L861">	static class MostPreferredFirstComparator implements</span>
			Comparator&lt;ProductSummary&gt; {

		@Override
		public int compare(ProductSummary p1, ProductSummary p2) {
<span class="fc bfc" id="L866" title="All 2 branches covered.">			if (p1.getPreferredWeight() &gt; p2.getPreferredWeight()) {</span>
<span class="fc" id="L867">				return -1;</span>
<span class="fc bfc" id="L868" title="All 2 branches covered.">			} else if (p1.getPreferredWeight() &lt; p2.getPreferredWeight()) {</span>
<span class="fc" id="L869">				return 1;</span>
			} else {
<span class="fc" id="L871">				Date p1Update = p1.getUpdateTime();</span>
<span class="fc" id="L872">				Date p2Update = p2.getUpdateTime();</span>
<span class="fc bfc" id="L873" title="All 2 branches covered.">				if (p1Update.after(p2Update)) {</span>
<span class="fc" id="L874">					return -1;</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">				} else if (p2Update.after(p1Update)) {</span>
<span class="fc" id="L876">					return 1;</span>
				} else {
<span class="fc" id="L878">					return 0;</span>
				}
			}
		}
	}

	@Override
	public int compareTo(Event that) {
		int r;

<span class="fc" id="L888">		List&lt;ProductSummary&gt; thisProducts = this.getProductList();</span>
<span class="fc" id="L889">		List&lt;ProductSummary&gt; thatProducts = that.getProductList();</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">		if ((r = (thatProducts.size() - thisProducts.size())) != 0) {</span>
<span class="nc" id="L891">			return r;</span>
		}

<span class="fc" id="L894">		Iterator&lt;ProductSummary&gt; thisIter = thisProducts.iterator();</span>
<span class="fc" id="L895">		Iterator&lt;ProductSummary&gt; thatIter = thatProducts.iterator();</span>
<span class="pc bpc" id="L896" title="1 of 4 branches missed.">		while (thisIter.hasNext() &amp;&amp; thatIter.hasNext()) {</span>
			// just compare product ids for now
<span class="fc" id="L898">			r = thisIter.next().getId().compareTo(thatIter.next().getId());</span>
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">			if (r != 0) {</span>
<span class="nc" id="L900">				return r;</span>
			}
		}

<span class="fc" id="L904">		return 0;</span>
	}

	/**
	 * Find the most preferred product.
	 *
	 * If preferredType is not null, products of this type are favored over
	 * those not of this type.
	 *
	 * If preferredNotNullProperty is not null, products that have this property
	 * set are favored over those without this property set.
	 *
	 * @param products
	 *            the list of products to search.
	 * @param preferredType
	 *            the preferred product type, if available.
	 * @param preferredNotNullProperty
	 *            the preferred property name, if available.
	 * @return The most preferred product summary of the given type.
	 */
	public static ProductSummary getMostPreferred(
			final List&lt;ProductSummary&gt; products, final String preferredType,
			final String preferredNotNullProperty) {
<span class="nc" id="L927">		ProductSummary mostPreferred = null;</span>

<span class="nc" id="L929">		Iterator&lt;ProductSummary&gt; iter = products.iterator();</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">		while (iter.hasNext()) {</span>
<span class="nc" id="L931">			ProductSummary next = iter.next();</span>

			// ignore products that don't have the preferredNotNullProperty
<span class="nc bnc" id="L934" title="All 2 branches missed.">			if (preferredNotNullProperty != null</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">					&amp;&amp; next.getProperties().get(preferredNotNullProperty) == null) {</span>
<span class="nc" id="L936">				continue;</span>
			}

<span class="nc bnc" id="L939" title="All 2 branches missed.">			if (mostPreferred == null) {</span>
				// first product is most preferred so far
<span class="nc" id="L941">				mostPreferred = next;</span>
<span class="nc" id="L942">				continue;</span>
			}

<span class="nc bnc" id="L945" title="All 2 branches missed.">			if (preferredType != null) {</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">				if (next.getType().equals(preferredType)) {</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">					if (!mostPreferred.getType().equals(preferredType)) {</span>
						// prefer products of this type
<span class="nc" id="L949">						mostPreferred = next;</span>
					}
<span class="nc bnc" id="L951" title="All 2 branches missed.">				} else if (mostPreferred.getType().equals(preferredType)) {</span>
					// already have preferred product of preferred type
<span class="nc" id="L953">					continue;</span>
				}
			}

<span class="nc bnc" id="L957" title="All 2 branches missed.">			if (next.getPreferredWeight() &gt; mostPreferred.getPreferredWeight()) {</span>
				// higher preferred weight
<span class="nc" id="L959">				mostPreferred = next;</span>
<span class="nc" id="L960">			} else if (next.getPreferredWeight() == mostPreferred</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">					.getPreferredWeight()</span>
<span class="nc" id="L962">					&amp;&amp; next.getUpdateTime()</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">							.after(mostPreferred.getUpdateTime())) {</span>
				// same preferred weight, newer update
<span class="nc" id="L965">				mostPreferred = next;</span>
			}
<span class="nc" id="L967">		}</span>

<span class="nc" id="L969">		return mostPreferred;</span>
	}

	/**
	 * Remove deleted products from the list.
	 *
	 * @param products
	 *            list of products to filter.
	 * @return copy of the products list with deleted products removed.
	 */
	public static List&lt;ProductSummary&gt; getWithoutDeleted(
			final List&lt;ProductSummary&gt; products) {
<span class="fc" id="L981">		List&lt;ProductSummary&gt; withoutDeleted = new ArrayList&lt;ProductSummary&gt;();</span>

<span class="fc" id="L983">		Iterator&lt;ProductSummary&gt; iter = products.iterator();</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L985">			ProductSummary next = iter.next();</span>
<span class="fc bfc" id="L986" title="All 2 branches covered.">			if (!next.isDeleted()) {</span>
<span class="fc" id="L987">				withoutDeleted.add(next);</span>
			}
<span class="fc" id="L989">		}</span>

<span class="fc" id="L991">		return withoutDeleted;</span>
	}

	/**
	 * Remove deleted products from the list.
	 *
	 * @param products
	 *            list of products to filter.
	 * @return copy of the products list with deleted products removed.
	 */
	public static List&lt;ProductSummary&gt; getWithEventId(
			final List&lt;ProductSummary&gt; products) {
<span class="nc" id="L1003">		List&lt;ProductSummary&gt; withEventId = new ArrayList&lt;ProductSummary&gt;();</span>

<span class="nc" id="L1005">		Iterator&lt;ProductSummary&gt; iter = products.iterator();</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">		while (iter.hasNext()) {</span>
<span class="nc" id="L1007">			ProductSummary next = iter.next();</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">			if (next.getEventId() != null) {</span>
<span class="nc" id="L1009">				withEventId.add(next);</span>
			}
<span class="nc" id="L1011">		}</span>

<span class="nc" id="L1013">		return withEventId;</span>
	}

	/**
	 * Remove old versions of products from the list.
	 *
	 * @param products
	 *            list of products to filter.
	 * @return a copy of the products list with products of the same
	 *         source+type+code but with older updateTimes (superseded) removed.
	 */
	public static List&lt;ProductSummary&gt; getWithoutSuperseded(
			final List&lt;ProductSummary&gt; products) {
		// place product into latest, keyed by source+type+code,
		// keeping only most recent update for each key
<span class="fc" id="L1028">		Map&lt;String, ProductSummary&gt; latest = new HashMap&lt;String, ProductSummary&gt;();</span>
<span class="fc" id="L1029">		Iterator&lt;ProductSummary&gt; iter = products.iterator();</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L1031">			ProductSummary summary = iter.next();</span>
<span class="fc" id="L1032">			ProductId id = summary.getId();</span>

			// key is combination of source, type, and code
			// since none of these may contain &quot;:&quot;, it is used as a delimiter to
			// prevent collisions.
<span class="fc" id="L1037">			String key = new StringBuffer(id.getSource()).append(&quot;:&quot;).append(</span>
<span class="fc" id="L1038">					id.getType()).append(&quot;:&quot;).append(id.getCode()).toString();</span>
<span class="fc bfc" id="L1039" title="All 2 branches covered.">			if (!latest.containsKey(key)) {</span>
				// first product
<span class="fc" id="L1041">				latest.put(key, summary);</span>
			} else {
				// keep latest product
<span class="fc" id="L1044">				ProductSummary other = latest.get(key);</span>
<span class="fc bfc" id="L1045" title="All 2 branches covered.">				if (other.getId().getUpdateTime().before(id.getUpdateTime())) {</span>
<span class="fc" id="L1046">					latest.put(key, summary);</span>
				}
			}
<span class="fc" id="L1049">		}</span>

		// those that are in the latest map have not been superseded
<span class="fc" id="L1052">		return new ArrayList&lt;ProductSummary&gt;(latest.values());</span>
	}

	/**
	 * Sort a list of products, most preferred first.
	 *
	 * @param products
	 *            the list of products to sort.
	 * @return a copy of the list sorted with most preferred first.
	 */
	public static List&lt;ProductSummary&gt; getSortedMostPreferredFirst(
			final List&lt;ProductSummary&gt; products) {
<span class="fc" id="L1064">		List&lt;ProductSummary&gt; mostPreferredFirst = new ArrayList&lt;ProductSummary&gt;(</span>
				products);
<span class="fc" id="L1066">		Collections</span>
<span class="fc" id="L1067">				.sort(mostPreferredFirst, new MostPreferredFirstComparator());</span>
<span class="fc" id="L1068">		return mostPreferredFirst;</span>
	}

	static List&lt;ProductSummary&gt; productTypeMapToList(
			final Map&lt;String, List&lt;ProductSummary&gt;&gt; products) {
<span class="fc" id="L1073">		List&lt;ProductSummary&gt; list = new ArrayList&lt;ProductSummary&gt;();</span>

<span class="fc" id="L1075">		Iterator&lt;String&gt; iter = products.keySet().iterator();</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L1077">			list.addAll(products.get(iter.next()));</span>
		}

<span class="fc" id="L1080">		return list;</span>
	}

	static Map&lt;String, List&lt;ProductSummary&gt;&gt; productListToTypeMap(
			final List&lt;ProductSummary&gt; products) {
<span class="nc" id="L1085">		Map&lt;String, List&lt;ProductSummary&gt;&gt; typeMap = new HashMap&lt;String, List&lt;ProductSummary&gt;&gt;();</span>

<span class="nc" id="L1087">		Iterator&lt;ProductSummary&gt; iter = products.iterator();</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">		while (iter.hasNext()) {</span>
<span class="nc" id="L1089">			ProductSummary product = iter.next();</span>
<span class="nc" id="L1090">			List&lt;ProductSummary&gt; typeProducts = typeMap.get(product.getType());</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">			if (typeProducts == null) {</span>
<span class="nc" id="L1092">				typeProducts = new ArrayList&lt;ProductSummary&gt;();</span>
<span class="nc" id="L1093">				typeMap.put(product.getType(), typeProducts);</span>
			}
<span class="nc" id="L1095">			typeProducts.add(product);</span>
<span class="nc" id="L1096">		}</span>

<span class="nc" id="L1098">		return typeMap;</span>
	}

	/**
	 * Return a list of sub-events that make up this event.
	 *
	 * Event lines are drawn by eventid. Products that have no eventid are
	 * included with the sub event whose id is considered preferred.
	 *
	 * @return map from eventid to event object with products for that eventid.
	 */
	public Map&lt;String, Event&gt; getSubEvents() {
		// Map of sub-events keyed by product &quot;eventId&quot;
<span class="fc" id="L1111">		Map&lt;String, Event&gt; subEvents = new HashMap&lt;String, Event&gt;();</span>

		// Map of events by source_type_code
<span class="fc" id="L1114">		Map&lt;String, Event&gt; productEvents = new HashMap&lt;String, Event&gt;();</span>

		// this is the event that will have products without event id...
<span class="fc" id="L1117">		String preferredEventId = this.getEventId();</span>
<span class="fc" id="L1118">		Event preferredSubEvent = new Event();</span>
		// put a placeholder with no products into the map for this purpose.
<span class="fc" id="L1120">		subEvents.put(preferredEventId, preferredSubEvent);</span>

		// List of all products associated to the current event
<span class="fc" id="L1123">		List&lt;ProductSummary&gt; allProducts = this.getAllProductList();</span>

		// handle products with a current version
<span class="fc" id="L1126">		HashSet&lt;ProductSummary&gt; withoutSuperseded = new HashSet&lt;ProductSummary&gt;(getWithoutSuperseded(allProducts));</span>
<span class="fc" id="L1127">		Iterator&lt;ProductSummary&gt; products = withoutSuperseded.iterator();</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">		while (products.hasNext()) {</span>
<span class="fc" id="L1129">			ProductSummary product = products.next();</span>
<span class="fc" id="L1130">			Event subEvent = null;</span>

<span class="fc" id="L1132">			String subEventId = product.getEventId();</span>
<span class="fc bfc" id="L1133" title="All 2 branches covered.">			if (subEventId == null) {</span>
				// maybe try to find another version of product with id?
<span class="fc" id="L1135">				subEvent = preferredSubEvent;</span>
			} else {
<span class="fc" id="L1137">				subEvent = subEvents.get(subEventId);</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">				if (subEvent == null) {</span>
					// first product for this sub event
<span class="fc" id="L1140">					subEvent = new Event();</span>
<span class="fc" id="L1141">					subEvents.put(subEventId, subEvent);</span>
				}
			}
<span class="fc" id="L1144">			subEvent.addProduct(product);</span>

<span class="fc" id="L1146">			ProductId id = product.getId();</span>
<span class="fc" id="L1147">			String key = id.getSource() + &quot;_&quot; + id.getType() + &quot;_&quot; + id.getCode();</span>
<span class="fc" id="L1148">			productEvents.put(key, subEvent);</span>
<span class="fc" id="L1149">		}</span>

		// handle superseded products
<span class="fc" id="L1152">		HashSet&lt;ProductSummary&gt; superseded = new HashSet&lt;ProductSummary&gt;(allProducts);</span>
<span class="fc" id="L1153">		superseded.removeAll(withoutSuperseded);</span>
<span class="fc" id="L1154">		products = superseded.iterator();</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">		while (products.hasNext()) {</span>
<span class="fc" id="L1156">			ProductSummary next = products.next();</span>
<span class="fc" id="L1157">			ProductId id = next.getId();</span>
<span class="fc" id="L1158">			String key = id.getSource() + &quot;_&quot; + id.getType() + &quot;_&quot; + id.getCode();</span>
<span class="fc" id="L1159">			Event subEvent = productEvents.get(key);</span>
<span class="fc" id="L1160">			subEvent.addProduct(next);</span>
<span class="fc" id="L1161">		}</span>

<span class="fc" id="L1163">		return subEvents;</span>
	}

	/**
	 * Check if this event has an associate product for another given Event.
	 *
	 * @param otherEvent
	 *            the other event.
	 * @return true if there is an associate product, false otherwise.
	 */
	public boolean hasAssociateProduct(final Event otherEvent) {
<span class="pc bpc" id="L1174" title="1 of 2 branches missed.">		if (otherEvent == null) {</span>
			// cannot have an association to a null event...
<span class="nc" id="L1176">			return false;</span>
		}

<span class="fc" id="L1179">		String otherEventSource = otherEvent.getSource();</span>
<span class="fc" id="L1180">		String otherEventSourceCode = otherEvent.getSourceCode();</span>
<span class="pc bpc" id="L1181" title="2 of 4 branches missed.">		if (otherEventSource == null || otherEventSourceCode == null) {</span>
			// same without source+code
<span class="nc" id="L1183">			return false;</span>
		}

		// search associate products
<span class="fc" id="L1187">		Iterator&lt;ProductSummary&gt; iter = getProducts(ASSOCIATE_PRODUCT_TYPE)</span>
<span class="fc" id="L1188">				.iterator();</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L1190">			ProductSummary associate = iter.next();</span>

<span class="pc bpc" id="L1192" title="1 of 2 branches missed.">			if (otherEventSource.equalsIgnoreCase(associate.getProperties()</span>
<span class="fc" id="L1193">					.get(OTHEREVENTSOURCE_PROPERTY))</span>
					&amp;&amp; otherEventSourceCode
<span class="pc bpc" id="L1195" title="1 of 2 branches missed.">							.equalsIgnoreCase(associate.getProperties().get(</span>
									OTHEREVENTSOURCECODE_PROPERTY))) {
				// associated
<span class="fc" id="L1198">				return true;</span>
			}
<span class="nc" id="L1200">		}</span>

<span class="fc" id="L1202">		return false;</span>
	}

	/**
	 * Check if this event has an disassociate product for another given Event.
	 *
	 * @param otherEvent
	 *            the other event.
	 * @return true if there is an disassociate product, false otherwise.
	 */
	public boolean hasDisassociateProduct(final Event otherEvent) {
<span class="pc bpc" id="L1213" title="1 of 2 branches missed.">		if (otherEvent == null) {</span>
			// cannot have an disassociation to a null event...
<span class="nc" id="L1215">			return false;</span>
		}

<span class="fc" id="L1218">		String otherEventSource = otherEvent.getSource();</span>
<span class="fc" id="L1219">		String otherEventSourceCode = otherEvent.getSourceCode();</span>
<span class="pc bpc" id="L1220" title="2 of 4 branches missed.">		if (otherEventSource == null || otherEventSourceCode == null) {</span>
			// same without source+code
<span class="nc" id="L1222">			return false;</span>
		}

		// search disassociate products
<span class="fc" id="L1226">		Iterator&lt;ProductSummary&gt; iter = getProducts(DISASSOCIATE_PRODUCT_TYPE)</span>
<span class="fc" id="L1227">				.iterator();</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">		while (iter.hasNext()) {</span>
<span class="fc" id="L1229">			ProductSummary associate = iter.next();</span>

<span class="pc bpc" id="L1231" title="1 of 2 branches missed.">			if (otherEventSource.equalsIgnoreCase(associate.getProperties()</span>
<span class="fc" id="L1232">					.get(OTHEREVENTSOURCE_PROPERTY))</span>
					&amp;&amp; otherEventSourceCode
<span class="pc bpc" id="L1234" title="1 of 2 branches missed.">							.equalsIgnoreCase(associate.getProperties().get(</span>
									OTHEREVENTSOURCECODE_PROPERTY))) {
				// disassociated
<span class="fc" id="L1237">				return true;</span>
			}
<span class="nc" id="L1239">		}</span>

<span class="fc" id="L1241">		return false;</span>
	}

	/**
	 * Same as isAssociated(that, new DefaultAssociator());
	 * @param that an event to test
	 * @return boolean true if associated, false otherwise
	 */
	public boolean isAssociated(final Event that) {
<span class="fc" id="L1250">		return this.isAssociated(that, new DefaultAssociator());</span>
	}

	/**
	 * Check if an event is associated to this event.
	 *
	 * Reasons events may be considered disassociated:
	 * &lt;ol&gt;
	 * &lt;li&gt;Share a common EVENTSOURCE with different EVENTSOURCECODE.&lt;/li&gt;
	 * &lt;li&gt;Either has a disassociate product for the other.&lt;/li&gt;
	 * &lt;li&gt;Preferred location in space and time is NOT nearby, and no other
	 * reason to associate.&lt;/li&gt;
	 * &lt;/ol&gt;
	 *
	 * Reasons events may be considered associated:
	 * &lt;ol&gt;
	 * &lt;li&gt;Share a common EVENTID&lt;/li&gt;
	 * &lt;li&gt;Either has an associate product for the other.&lt;/li&gt;
	 * &lt;li&gt;Their preferred location in space and time is nearby.&lt;/li&gt;
	 * &lt;/ol&gt;
	 *
	 * @param that
	 *            candidate event to test.
	 * @param associator
	 *            An associator to compare two events
	 * @return true if associated, false otherwise.
	 */
	public boolean isAssociated(final Event that, final Associator associator) {
<span class="fc" id="L1278">		return associator.eventsAssociated(this, that);</span>
	}

	/**
	 * Depending on logger level, takes in summary data and appends to buffer
	 * @param logger logger object
	 */
	public void log(final Logger logger) {
<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">		if (logger.isLoggable(Level.FINE)) {</span>
<span class="fc" id="L1287">			EventSummary summary = this.getEventSummary();</span>
<span class="fc" id="L1288">			logger.fine(new StringBuffer(&quot;Event&quot;)</span>
<span class="fc" id="L1289">					.append(&quot;indexid=&quot;).append(summary.getIndexId())</span>
<span class="fc" id="L1290">					.append(&quot;, eventid=&quot;).append(summary.getId())</span>
<span class="fc" id="L1291">					.append(&quot;, latitude=&quot;).append(summary.getLatitude())</span>
<span class="fc" id="L1292">					.append(&quot;, longitude=&quot;).append(summary.getLongitude())</span>
<span class="fc" id="L1293">					.append(&quot;, time=&quot;).append(summary.getTime())</span>
<span class="fc" id="L1294">					.append(&quot;, deleted=&quot;).append(summary.isDeleted()).toString());</span>

<span class="fc bfc" id="L1296" title="All 2 branches covered.">			if (logger.isLoggable(Level.FINER)) {</span>
<span class="fc" id="L1297">				StringBuffer buf = new StringBuffer(&quot;Products in event&quot;);</span>
<span class="fc" id="L1298">				List&lt;ProductSummary&gt; products = this.getAllProductList();</span>
<span class="fc" id="L1299">				Iterator&lt;ProductSummary&gt; iter = products.iterator();</span>
<span class="fc bfc" id="L1300" title="All 2 branches covered.">				while (iter.hasNext()) {</span>
<span class="fc" id="L1301">					ProductSummary next = iter.next();</span>
<span class="fc" id="L1302">					buf.append(&quot;\n\tstatus=&quot;).append(next.getStatus())</span>
<span class="fc" id="L1303">							.append(&quot;, id=&quot;).append(next.getId().toString())</span>
<span class="fc" id="L1304">							.append(&quot;, eventid=&quot;).append(next.getEventId())</span>
<span class="fc" id="L1305">							.append(&quot;, latitude=&quot;).append(next.getEventLatitude())</span>
<span class="fc" id="L1306">							.append(&quot;, longitude=&quot;).append(next.getEventLongitude())</span>
<span class="fc" id="L1307">							.append(&quot;, time=&quot;).append(next.getEventTime());</span>
<span class="fc" id="L1308">				}</span>
<span class="fc" id="L1309">				logger.finer(buf.toString());</span>
			}
		}
<span class="fc" id="L1312">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>