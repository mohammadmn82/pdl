<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultIndexerListener.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.earthquake.indexer</a> &gt; <span class="el_source">DefaultIndexerListener.java</span></div><h1>DefaultIndexerListener.java</h1><pre class="source lang-java linenums">package gov.usgs.earthquake.indexer;

import gov.usgs.earthquake.indexer.IndexerChange.IndexerChangeType;
import gov.usgs.earthquake.product.AbstractListener;
import gov.usgs.earthquake.product.ProductId;
import gov.usgs.earthquake.util.CompareUtil;
import gov.usgs.util.Config;

import java.util.Iterator;
import java.util.List;
import java.util.logging.Logger;

/**
 * DefaultIndexerListener provides a starting point from which all
 * IndexerListeners may extend.
 *
 * As a child-class of the AbstractListener, this may be configured with all of
 * the parent parameters and also accepts the following:
 *
 * &lt;dl&gt;
 * &lt;dt&gt;command&lt;/dt&gt;
 * &lt;dd&gt;(Required) The command to execute. This must be an executable command and
 * may include arguments. Any product-specific arguments are appended at the end
 * of command.&lt;/dd&gt;
 *
 * &lt;dt&gt;storage&lt;/dt&gt;
 * &lt;dd&gt;(Required) A directory used to store all products. Each product is
 * extracted into a separate directory within this directory and is referenced
 * by the --directory=/path/to/directory argument when command is executed.&lt;/dd&gt;
 *
 * &lt;dt&gt;processUnassociated&lt;/dt&gt;
 * &lt;dd&gt;(Optional, Default = false) Whether or not to process unassociated
 * products. Valid values are &quot;true&quot; and &quot;false&quot;.&lt;/dd&gt;
 *
 * &lt;dt&gt;processPreferredOnly&lt;/dt&gt;
 * &lt;dd&gt;(Optional, Default = false) Whether or not to process only preferred
 * products of the type accepted by this listener. Valid values are &quot;true&quot; and
 * &quot;false&quot;.&lt;/dd&gt;
 *
 * &lt;dt&gt;ignoreArchive&lt;/dt&gt;
 * &lt;dd&gt;(Optional, Default = false) Whether or not to ignore EVENT_ARCHIVED and
 * PRODUCT_ARCHIVED indexer events. Value values are &quot;true&quot; and &quot;false&quot;.&lt;/dd&gt;
 *
 * &lt;/dl&gt;
 */
<span class="fc" id="L46">public class DefaultIndexerListener extends AbstractListener implements</span>
		IndexerListener {
	/** Logging object. */
<span class="fc" id="L49">	private static final Logger LOGGER = Logger</span>
<span class="fc" id="L50">			.getLogger(DefaultIndexerListener.class.getName());</span>

	/** Property for process preferred only */
	public static final String PROCESS_PREFERRED_ONLY_PROPERTY = &quot;processPreferredOnly&quot;;
	/** Default state of process preferred only */
	public static final String PROCESS_PREFERRED_ONLY_DEFAULT = &quot;false&quot;;

	/** Property for process unassociated */
	public static final String PROCESS_UNASSOCIATED_PROPERTY = &quot;processUnassociated&quot;;
	/** Default state of process unassociated */
	public static final String PROCESS_UNASSOCIATED_DEFAULT = &quot;true&quot;;

	/** Property for process only when event change */
	public static final String PROCESS_ONLY_WHEN_EVENT_CHANGE_PROPERTY = &quot;processOnlyWhenEventChanged&quot;;
	/** Default state of process only when event change */
	public static final String PROCESS_ONLY_WHEN_EVENT_CHANGE_DEFAULT = &quot;false&quot;;

	/** Property for Ignore archive */
	public static final String IGNORE_ARCHIVE_PROPERTY = &quot;ignoreArchive&quot;;
	/** Default state of ignore archive */
	public static final String IGNORE_ARCHIVE_DEFAULT = &quot;true&quot;;

	/** Whether or not to process only preferred products. */
<span class="fc" id="L73">	private boolean processOnlyPreferredProducts = false;</span>

	/** Whether or not to process unassociated products. */
<span class="fc" id="L76">	private boolean processUnassociatedProducts = true;</span>

	/**
	 * Whether or not to process updates that don't change preferred event
	 * parameters.
	 */
<span class="fc" id="L82">	private boolean processOnlyWhenEventChanged = false;</span>

	/** Whether or not to process archive events. */
<span class="fc" id="L85">	private boolean ignoreArchive = false;</span>

	@Override
	public void onIndexerEvent(IndexerEvent event) throws Exception {
<span class="nc" id="L89">		StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L90">		Iterator&lt;IndexerChange&gt; changes = event.getIndexerChanges().iterator();</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">		while (changes.hasNext()) {</span>
<span class="nc" id="L92">			IndexerChange change = changes.next();</span>
<span class="nc" id="L93">			buf.append(&quot;\n&quot;).append(change.getType().toString()).append(&quot; &quot;);</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">			if (change.getOriginalEvent() == null) {</span>
<span class="nc" id="L95">				buf.append(&quot;null&quot;);</span>
			} else {
<span class="nc" id="L97">				buf.append(change.getOriginalEvent().getEventId());</span>
			}
<span class="nc" id="L99">			buf.append(&quot; =&gt; &quot;);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">			if (change.getNewEvent() == null) {</span>
<span class="nc" id="L101">				buf.append(&quot;null&quot;);</span>
			} else {
<span class="nc" id="L103">				buf.append(change.getNewEvent().getEventId());</span>
			}
<span class="nc" id="L105">		}</span>
<span class="nc" id="L106">		LOGGER.info(buf.toString());</span>
<span class="nc" id="L107">	}</span>

	/**
	 * @param change
	 *            the indexer event that has occurred
	 * @return whether this external indexer listener handles this product type
	 * @throws Exception if error occurs
	 */
	public boolean accept(IndexerEvent change) throws Exception {
<span class="fc" id="L116">		String productType = null;</span>

<span class="fc bfc" id="L118" title="All 2 branches covered.">		if (change.getSummary() != null) {</span>
<span class="fc" id="L119">			ProductId productId = change.getSummary().getId();</span>

<span class="fc" id="L121">			productType = productId.getType();</span>

			// use default notification listener first
<span class="fc bfc" id="L124" title="All 2 branches covered.">			if (!super.accept(productId)) {</span>
<span class="fc" id="L125">				return false;</span>
			}
		}

<span class="fc" id="L129">		List&lt;Event&gt; events = change.getEvents();</span>
<span class="pc bpc" id="L130" title="3 of 4 branches missed.">		if (!processUnassociatedProducts &amp;&amp; events.size() == 0) {</span>
<span class="nc" id="L131">			LOGGER.fine(&quot;[&quot; + getName() + &quot;] product is unassociated&quot;);</span>
<span class="nc" id="L132">			return false;</span>
		}

<span class="pc bpc" id="L135" title="1 of 4 branches missed.">		if (processOnlyPreferredProducts &amp;&amp; events.size() &gt; 0) {</span>
			// check if preferred for any event
<span class="fc" id="L137">			boolean isPreferred = false;</span>

			// can only be a preferred product if a summary associated
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">			if (productType != null) {</span>
<span class="fc" id="L141">				Iterator&lt;Event&gt; iter = events.iterator();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">				while (iter.hasNext()) {</span>
<span class="fc" id="L143">					Event event = iter.next();</span>
<span class="fc" id="L144">					ProductSummary preferred = event</span>
<span class="fc" id="L145">							.getPreferredProduct(productType);</span>
<span class="pc bpc" id="L146" title="1 of 4 branches missed.">					if (preferred != null &amp;&amp; preferred.getId().equals(</span>
<span class="fc" id="L147">							change.getSummary().getId())) {</span>
						// it is the most preferred product for this event
<span class="fc" id="L149">						isPreferred = true;</span>
<span class="fc" id="L150">						break;</span>
					}
<span class="fc" id="L152">				}</span>
			}

<span class="fc bfc" id="L155" title="All 2 branches covered.">			if (!isPreferred) {</span>
<span class="fc" id="L156">				LOGGER.fine(&quot;[&quot; + getName()</span>
						+ &quot;] product is not preferred in any event&quot;);
<span class="fc" id="L158">				return false;</span>
			}
		}

		// accept by default
<span class="fc" id="L163">		return true;</span>
	}

	/**
	 * Returns a boolean based on if the preferred event params have changed
	 * Returns false if change is an archive indexer
	 * @param event an IndexerEvent
	 * @param change and IndexerChange
	 * @return boolean
	 * @throws Exception if error occurs
	 */
	public boolean accept(IndexerEvent event, IndexerChange change)
			throws Exception {
		// check whether this is an archive indexer change
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">		if (ignoreArchive</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">				&amp;&amp; (change.getType() == IndexerChangeType.PRODUCT_ARCHIVED</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">				|| change.getType() == IndexerChangeType.EVENT_ARCHIVED)) {</span>
<span class="nc" id="L180">			return false;</span>
		}

		// see if preferred event parameters have changed
<span class="fc bfc" id="L184" title="All 2 branches covered.">		if (processOnlyWhenEventChanged) {</span>
<span class="fc" id="L185">			Event originalEvent = change.getOriginalEvent();</span>
<span class="fc" id="L186">			Event newEvent = change.getNewEvent();</span>
<span class="fc bfc" id="L187" title="All 4 branches covered.">			if (originalEvent != null &amp;&amp; newEvent != null) {</span>
<span class="fc" id="L188">				EventSummary originalEventSummary = originalEvent.getEventSummary();</span>
<span class="fc" id="L189">				EventSummary newEventSummary = newEvent.getEventSummary();</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">				if (CompareUtil.nullSafeCompare(</span>
<span class="fc" id="L191">						originalEventSummary.getMagnitude(),</span>
<span class="fc" id="L192">						newEventSummary.getMagnitude()) != 0) {</span>
					// magnitude changed
<span class="fc bfc" id="L194" title="All 2 branches covered.">				} else if (CompareUtil.nullSafeCompare(</span>
<span class="fc" id="L195">						originalEventSummary.getLatitude(),</span>
<span class="fc" id="L196">						newEventSummary.getLatitude()) != 0) {</span>
					// latitude changed
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">				} else if (CompareUtil.nullSafeCompare(</span>
<span class="fc" id="L199">						originalEventSummary.getLongitude(),</span>
<span class="fc" id="L200">						newEventSummary.getLongitude()) != 0) {</span>
					// longitude changed
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">				} else if (CompareUtil.nullSafeCompare(</span>
<span class="fc" id="L203">						originalEventSummary.getDepth(),</span>
<span class="fc" id="L204">						newEventSummary.getDepth()) != 0) {</span>
					// depth changed
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">				} else if (CompareUtil.nullSafeCompare(</span>
<span class="fc" id="L207">						originalEventSummary.getTime(),</span>
<span class="fc" id="L208">						newEventSummary.getTime()) != 0) {</span>
					// time changed
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">				} else if (originalEventSummary.isDeleted() != newEventSummary.isDeleted()) {</span>
					// status changed
				} else {
					// preferred event parameters haven't changed
<span class="fc" id="L214">					return false;</span>
				}
			}
		}

		// accept changes by default
<span class="fc" id="L220">		return true;</span>
	}

	public void configure(Config config) throws Exception {
<span class="nc" id="L224">		super.configure(config);</span>

<span class="nc" id="L226">		processOnlyPreferredProducts = Boolean.valueOf(config</span>
<span class="nc" id="L227">				.getProperty(PROCESS_PREFERRED_ONLY_PROPERTY,</span>
						PROCESS_PREFERRED_ONLY_DEFAULT));
<span class="nc" id="L229">		LOGGER.config(&quot;[&quot; + getName() + &quot;] process only preferred products = &quot;</span>
				+ processOnlyPreferredProducts);

<span class="nc" id="L232">		processUnassociatedProducts = Boolean.valueOf(config.getProperty(</span>
				PROCESS_UNASSOCIATED_PROPERTY, PROCESS_UNASSOCIATED_DEFAULT));
<span class="nc" id="L234">		LOGGER.config(&quot;[&quot; + getName() + &quot;] process unassociated products = &quot;</span>
				+ processUnassociatedProducts);

<span class="nc" id="L237">		processOnlyWhenEventChanged = Boolean.valueOf(config.getProperty(</span>
				PROCESS_ONLY_WHEN_EVENT_CHANGE_PROPERTY,
				PROCESS_ONLY_WHEN_EVENT_CHANGE_DEFAULT));
<span class="nc" id="L240">		LOGGER.config(&quot;[&quot; + getName() + &quot;] process only when event changed = &quot;</span>
				+ processOnlyWhenEventChanged);

<span class="nc" id="L243">		ignoreArchive = Boolean.valueOf(config.getProperty(</span>
				IGNORE_ARCHIVE_PROPERTY, IGNORE_ARCHIVE_DEFAULT));
<span class="nc" id="L245">		LOGGER.config(&quot;[&quot; + getName() + &quot;] ignore archive changes = &quot;</span>
				+ ignoreArchive);
<span class="nc" id="L247">	}</span>

	/**
	 * @return whether only preferred products are processed
	 */
	public boolean getProcessOnlyPreferredProducts() {
<span class="nc" id="L253">		return processOnlyPreferredProducts;</span>
	}

	/**
	 * @param processOnlyPreferredProducts
	 *            whether to process ony preferred products
	 */
	public void setProcessOnlyPreferredProducts(
			final boolean processOnlyPreferredProducts) {
<span class="fc" id="L262">		this.processOnlyPreferredProducts = processOnlyPreferredProducts;</span>
<span class="fc" id="L263">	}</span>

	/** @param processUnassociatedProducts to set */
	public void setProcessUnassociatedProducts(
			final boolean processUnassociatedProducts) {
<span class="nc" id="L268">		this.processUnassociatedProducts = processUnassociatedProducts;</span>
<span class="nc" id="L269">	}</span>

	/** @return boolean processUnassociatedProducts */
	public boolean getProcessUnassociatedProducts() {
<span class="nc" id="L273">		return processUnassociatedProducts;</span>
	}

	/** @return boolean processOnlyWhenEventChanged */
	public boolean isProcessOnlyWhenEventChanged() {
<span class="nc" id="L278">		return processOnlyWhenEventChanged;</span>
	}

	/** @param processOnlyWhenEventChanged to set */
	public void setProcessOnlyWhenEventChanged(
			boolean processOnlyWhenEventChanged) {
<span class="fc" id="L284">		this.processOnlyWhenEventChanged = processOnlyWhenEventChanged;</span>
<span class="fc" id="L285">	}</span>

	/** @return ignoreArchive */
	public boolean isIgnoreArchive() {
<span class="nc" id="L289">		return ignoreArchive;</span>
	}

	/** @param ignoreArchive to set */
	public void setIgnoreArchive(boolean ignoreArchive) {
<span class="nc" id="L294">		this.ignoreArchive = ignoreArchive;</span>
<span class="nc" id="L295">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>