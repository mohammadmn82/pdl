<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileProductStorage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.earthquake.distribution</a> &gt; <span class="el_source">FileProductStorage.java</span></div><h1>FileProductStorage.java</h1><pre class="source lang-java linenums">/*
 * FileProductStorage
 */
package gov.usgs.earthquake.distribution;

import gov.usgs.earthquake.product.ByteContent;
import gov.usgs.earthquake.product.Content;
import gov.usgs.earthquake.product.Product;
import gov.usgs.earthquake.product.ProductId;
import gov.usgs.earthquake.product.io.DirectoryProductHandler;
import gov.usgs.earthquake.product.io.DirectoryProductSource;
import gov.usgs.earthquake.product.io.FilterProductHandler;
import gov.usgs.earthquake.product.io.ObjectProductHandler;
import gov.usgs.earthquake.product.io.ObjectProductSource;
import gov.usgs.earthquake.product.io.ProductHandler;
import gov.usgs.earthquake.product.io.ProductSource;
import gov.usgs.util.Config;
import gov.usgs.util.DefaultConfigurable;
import gov.usgs.util.FileUtils;
import gov.usgs.util.ObjectLock;
import gov.usgs.util.StringUtils;

import java.io.File;
import java.net.URL;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Store products in the file system.
 *
 * This implementation of ProductStorage extracts products into directories.
 *
 * The FileProductStorage implements the Configurable interface and can use the
 * following configuration parameters:
 *
 * &lt;dl&gt;
 * &lt;dt&gt;directory&lt;/dt&gt;
 * &lt;dd&gt;(Optional, default = storage) The base directory where products are
 * stored. Each product is stored in a separate directory within this directory.
 * &lt;/dd&gt;
 *
 * &lt;dt&gt;verifySignatures&lt;/dt&gt;
 * &lt;dd&gt;(Optional, default = off) Whether or not to verify signatures:
 * &lt;dl&gt;
 * &lt;dt&gt;off&lt;/dt&gt;
 * &lt;dd&gt;no verification&lt;/dd&gt;
 *
 * &lt;dt&gt;test&lt;/dt&gt;
 * &lt;dd&gt;test but accept invalid signatures&lt;/dd&gt;
 *
 * &lt;dt&gt;anything else&lt;/dt&gt;
 * &lt;dd&gt;reject invalid signatures.&lt;/dd&gt;
 * &lt;/dl&gt;
 * &lt;/dd&gt;
 *
 * &lt;dt&gt;keychain&lt;/dt&gt;
 * &lt;dd&gt;(Optional) List of key section names to load for signature verification.&lt;/dd&gt;
 * &lt;/dl&gt;
 *
 * An attempt is made to make storage operations atomic by using read and write
 * locks. While a write operation (store or remove) is in progress, read
 * operations will block. It is possible for a remove operation to occur between
 * the time getProduct() returns and the time when product contents are actually
 * loaded from a file. Users who are concerned about this should use the
 * getInMemoryProduct() method, which holds a read lock until all product files
 * are read.
 *
 * To override the directory structure or format, override one or more of the
 * following methods:
 *
 * &lt;pre&gt;
 * String getProductPath(ProductId)
 * ProductSource getProductSourceFormat(File)
 * ProductOutput getProductHandlerFormat(File)
 * &lt;/pre&gt;
 */
public class FileProductStorage extends DefaultConfigurable implements
		ProductStorage {

	/** Logging object. */
<span class="fc" id="L89">	private static final Logger LOGGER = Logger</span>
<span class="fc" id="L90">			.getLogger(FileProductStorage.class.getName());</span>

	/** Property for configured listeners */
	public static final String STORAGE_LISTENER_PROPERTY = &quot;listeners&quot;;

	/** Storage path property name used by Configurable interface. */
	public static final String DIRECTORY_PROPERTY_NAME = &quot;directory&quot;;
	/** Default storage path if none is provided. */
	public static final String DEFAULT_DIRECTORY = &quot;storage&quot;;

	/** Property for whether or not to hash file paths. */
	public static final String USE_HASH_PATHS_PROPERTY = &quot;useHashes&quot;;
	/** Do not use hashes (Default). */
	public static final boolean USE_HASH_PATHS_DEFAULT = false;

	/** Property for legacyStorages. */
	public static final String LEGACY_STORAGES_PROPERTY = &quot;legacyStorages&quot;;

	/** Base directory for product storage. */
	private File baseDirectory;

<span class="fc" id="L111">	private boolean useHashes = USE_HASH_PATHS_DEFAULT;</span>

	/** Locks used to make storage operations atomic. */
<span class="fc" id="L114">	private ObjectLock&lt;ProductId&gt; storageLocks = new ObjectLock&lt;ProductId&gt;();</span>

<span class="fc" id="L116">	private SignatureVerifier verifier = new SignatureVerifier();</span>

	/**
	 * @return the storageLocks
	 */
	public ObjectLock&lt;ProductId&gt; getStorageLocks() {
<span class="fc" id="L122">		return storageLocks;</span>
	}

<span class="fc" id="L125">	private Map&lt;StorageListener, ExecutorService&gt; listeners = new HashMap&lt;StorageListener, ExecutorService&gt;();</span>

	/**
	 * A list of product storages used only for retrieving products, never for
	 * storing. Assists with migration between formats and other settings.
	 */
<span class="fc" id="L131">	private final ArrayList&lt;ProductStorage&gt; legacyStorages = new ArrayList&lt;ProductStorage&gt;();</span>

	/**
	 * Create this digest once, and clone it later. Only used if
	 * &lt;code&gt;useHashed&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.
	 */
	private static final MessageDigest SHA_DIGEST;
	static {
<span class="fc" id="L139">		MessageDigest digest = null;</span>
		try {
<span class="fc" id="L141">			digest = MessageDigest.getInstance(&quot;SHA&quot;);</span>
<span class="nc" id="L142">		} catch (Exception e) {</span>
<span class="nc" id="L143">			LOGGER.warning(&quot;Unable to create SHA Digest for HashFileProductStorage&quot;);</span>
<span class="nc" id="L144">			digest = null;</span>
<span class="fc" id="L145">		}</span>
<span class="fc" id="L146">		SHA_DIGEST = digest;</span>
<span class="fc" id="L147">	}</span>

	/**
	 * This is chosen because 16^3 = 4096 &amp;lt; 32000, which is the ext3
	 * subdirectory limit.
	 */
	public static final int DIRECTORY_NAME_LENGTH = 3;

	/**
	 * Create a new FileProductStorage using the default storage path.
	 */
	public FileProductStorage() {
<span class="fc" id="L159">		this(new File(DEFAULT_DIRECTORY));</span>
<span class="fc" id="L160">	}</span>

	/**
	 * Create a new FileProductStorage.
	 *
	 * @param baseDirectory
	 *            the base directory for all products being stored.
	 */
<span class="fc" id="L168">	public FileProductStorage(final File baseDirectory) {</span>
<span class="fc" id="L169">		this.baseDirectory = baseDirectory;</span>
<span class="fc" id="L170">	}</span>

	/**
	 * Configure this object.
	 *
	 * Expects a key named &quot;directory&quot;.
	 */
	public void configure(Config config) throws Exception {
<span class="fc" id="L178">		String directory = config.getProperty(DIRECTORY_PROPERTY_NAME,</span>
				DEFAULT_DIRECTORY);
<span class="fc" id="L180">		baseDirectory = new File(directory);</span>
<span class="fc" id="L181">		LOGGER.config(&quot;[&quot; + getName() + &quot;] using storage directory &quot;</span>
<span class="fc" id="L182">				+ baseDirectory.getCanonicalPath());</span>

		// Configure verifier
<span class="fc" id="L185">		verifier.configure(config);</span>

		// Set up our configured listeners
<span class="fc" id="L188">		Iterator&lt;String&gt; listenerIter = StringUtils.split(</span>
<span class="fc" id="L189">				config.getProperty(STORAGE_LISTENER_PROPERTY), &quot;,&quot;).iterator();</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">		while (listenerIter.hasNext()) {</span>
<span class="nc" id="L191">			String listenerName = listenerIter.next();</span>
			try {
<span class="nc" id="L193">				StorageListener listener = (StorageListener) Config.getConfig()</span>
<span class="nc" id="L194">						.getObject(listenerName);</span>
<span class="nc" id="L195">				addStorageListener(listener);</span>
<span class="nc" id="L196">			} catch (Exception ccx) {</span>
<span class="nc" id="L197">				throw new ConfigurationException(&quot;[&quot; + getName()</span>
						+ &quot;] listener \&quot;&quot; + listenerName
<span class="nc" id="L199">						+ &quot;\&quot; was not properly configured. &quot; + ccx.getMessage());</span>
<span class="nc" id="L200">			}</span>
<span class="nc" id="L201">		}</span>

		// load legacy storages
<span class="fc" id="L204">		Iterator&lt;String&gt; legacyIter = StringUtils.split(</span>
<span class="fc" id="L205">				config.getProperty(LEGACY_STORAGES_PROPERTY), &quot;,&quot;).iterator();</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">		while (legacyIter.hasNext()) {</span>
<span class="nc" id="L207">			String legacyName = legacyIter.next();</span>
			try {
				ProductStorage legacyStorage = (ProductStorage) Config
<span class="nc" id="L210">						.getConfig().getObject(legacyName);</span>
<span class="nc" id="L211">				legacyStorages.add(legacyStorage);</span>
<span class="nc" id="L212">			} catch (Exception e) {</span>
<span class="nc" id="L213">				throw new ConfigurationException(&quot;[&quot; + getName()</span>
						+ &quot;] legacy storage '&quot; + legacyName
<span class="nc" id="L215">						+ &quot;' not properly configured. &quot; + e.getMessage());</span>
<span class="nc" id="L216">			}</span>
<span class="nc" id="L217">		}</span>
<span class="fc" id="L218">	}</span>

	@Override
	public synchronized void notifyListeners(final StorageEvent event) {
<span class="fc" id="L222">		Iterator&lt;StorageListener&gt; listenerIter = listeners.keySet().iterator();</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">		while (listenerIter.hasNext()) {</span>
<span class="nc" id="L224">			final StorageListener listener = listenerIter.next();</span>
<span class="nc" id="L225">			LOGGER.finer(&quot;[&quot; + getName() + &quot;] listener :: &quot;</span>
<span class="nc" id="L226">					+ listener.getClass().getCanonicalName());</span>
<span class="nc" id="L227">			final ExecutorService service = listeners.get(listener);</span>

<span class="nc" id="L229">			service.submit(new Runnable() {</span>

				public void run() {
<span class="nc" id="L232">					listener.onStorageEvent(event);</span>
<span class="nc" id="L233">				}</span>
			});
<span class="nc" id="L235">		}</span>
<span class="fc" id="L236">	}</span>

	@Override
	public void addStorageListener(final StorageListener listener) {
<span class="nc" id="L240">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] adding listener :: &quot;</span>
<span class="nc" id="L241">				+ listener.getClass().getCanonicalName());</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">		if (!listeners.containsKey(listener)) {</span>
<span class="nc" id="L243">			ExecutorService service = Executors.newSingleThreadExecutor();</span>
<span class="nc" id="L244">			listeners.put(listener, service);</span>
		}
<span class="nc" id="L246">	}</span>

	@Override
	public void removeStorageListener(final StorageListener listener) {
<span class="nc" id="L250">		ExecutorService service = listeners.remove(listener);</span>

<span class="nc bnc" id="L252" title="All 2 branches missed.">		if (service != null) {</span>
<span class="nc" id="L253">			service.shutdown();</span>
		}
<span class="nc" id="L255">	}</span>

	/**
	 * A method for subclasses to override the storage path.
	 *
	 * The returned path is appended to the base directory when storing and
	 * retrieving products.
	 *
	 * @param id
	 *            the product id to convert.
	 * @return the directory used to store id.
	 */
	public String getProductPath(final ProductId id) {

<span class="pc bpc" id="L269" title="1 of 2 branches missed.">		if (useHashes) {</span>
<span class="nc" id="L270">			return getHashedProductPath(id);</span>
		} else {
<span class="fc" id="L272">			return getNormalProductPath(id);</span>
		}
	}
	/**
	 * @param id Specific productID
	 * @return string buffer of hashed product path
	 */
	protected String getHashedProductPath(final ProductId id) {
		try {
			MessageDigest digest;
<span class="nc" id="L282">			synchronized (SHA_DIGEST) {</span>
<span class="nc" id="L283">				digest = ((MessageDigest) SHA_DIGEST.clone());</span>
<span class="nc" id="L284">			}</span>

<span class="nc" id="L286">			String hexDigest = toHexString(digest.digest(id.toString()</span>
<span class="nc" id="L287">					.getBytes()));</span>

<span class="nc" id="L289">			StringBuffer buf = new StringBuffer();</span>
			// start with product type, to give idea of available products and
			// disk usage when looking at filesystem
<span class="nc" id="L292">			buf.append(id.getType());</span>

			// sub directories based on hash
<span class="nc" id="L295">			int length = hexDigest.length();</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">			for (int i = 0; i &lt; length; i += DIRECTORY_NAME_LENGTH) {</span>
				String part;
<span class="nc bnc" id="L298" title="All 2 branches missed.">				if (i + DIRECTORY_NAME_LENGTH &lt; length) {</span>
<span class="nc" id="L299">					part = hexDigest.substring(i, i + DIRECTORY_NAME_LENGTH);</span>
				} else {
<span class="nc" id="L301">					part = hexDigest.substring(i);</span>
				}
<span class="nc" id="L303">				buf.append(File.separator);</span>
<span class="nc" id="L304">				buf.append(part);</span>
			}

<span class="nc" id="L307">			return buf.toString();</span>
<span class="nc" id="L308">		} catch (CloneNotSupportedException e) {</span>
			// fall back to parent class
<span class="nc" id="L310">			return getNormalProductPath(id);</span>
		}
	}

	/**
	 * Convert an array of bytes into a hex string. The string will always be
	 * twice as long as the input byte array, because bytes &lt; 0x10 are zero
	 * padded.
	 *
	 * @param bytes
	 *            byte array to convert to hex.
	 * @return hex string equivalent of input byte array.
	 */
	private String toHexString(final byte[] bytes) {
<span class="nc" id="L324">		StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L325">		int length = bytes.length;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">		for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L327">			String hex = Integer.toHexString(0xFF &amp; bytes[i]);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">			if (hex.length() == 1) {</span>
<span class="nc" id="L329">				buf.append('0');</span>
			}
<span class="nc" id="L331">			buf.append(hex);</span>
		}
<span class="nc" id="L333">		return buf.toString();</span>
	}

	/**
	 * @param id ProductId
	 * @return string buffer of normal product path
	 */
	public String getNormalProductPath(final ProductId id) {
<span class="fc" id="L341">		StringBuffer buf = new StringBuffer();</span>
<span class="fc" id="L342">		buf.append(id.getType());</span>
<span class="fc" id="L343">		buf.append(File.separator);</span>
<span class="fc" id="L344">		buf.append(id.getCode());</span>
<span class="fc" id="L345">		buf.append(File.separator);</span>
<span class="fc" id="L346">		buf.append(id.getSource());</span>
<span class="fc" id="L347">		buf.append(File.separator);</span>
<span class="fc" id="L348">		buf.append(id.getUpdateTime().getTime());</span>
<span class="fc" id="L349">		return buf.toString();</span>
	}

	/**
	 * A method for subclasses to override the storage format.
	 *
	 * When overriding this method, the method getProductSourceFormat should
	 * also be overridden.
	 *
	 * @param file
	 *            a file that should be converted into a ProductHandler.
	 * @return the ProductHandler.
	 * @throws Exception if error occurs
	 */
	protected ProductHandler getProductHandlerFormat(final File file)
			throws Exception {
<span class="fc" id="L365">		return new DirectoryProductHandler(file);</span>
	}

	/**
	 * A method for subclasses to override the storage format.
	 *
	 * When overriding this method, the method getProductHandlerFormat should
	 * also be overridden.
	 *
	 * @param file
	 *            a file that should be converted into a ProductSource.
	 * @return the ProductSource.
	 * @throws Exception if error occurs
	 */
	protected ProductSource getProductSourceFormat(final File file)
			throws Exception {
<span class="fc" id="L381">		return new DirectoryProductSource(file);</span>
	}

	/**
	 * Get the file or directory used to store a specific product.
	 *
	 * @param id
	 *            which product.
	 * @return a file or directory where the product would be stored.
	 */
	public File getProductFile(final ProductId id) {
<span class="fc" id="L392">		String path = getProductPath(id);</span>
		// remove any leading slash so path will always be within baseDirectory.
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">		if (path.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L395">			path = path.substring(1);</span>
		}
<span class="fc" id="L397">		return new File(baseDirectory, path);</span>
	}

	/**
	 * Get a product from storage.
	 *
	 * Calls the getProductSource method, and uses ObjectProductHandler to
	 * convert the ProductSource into a Product.
	 *
	 * @param id
	 *            the product to retrieve.
	 * @return the product, or null if not in this storage.
	 */
	public Product getProduct(ProductId id) throws Exception {
<span class="fc" id="L411">		ProductSource source = getProductSource(id);</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">		if (source == null) {</span>
<span class="fc" id="L413">			return null;</span>
		} else {
<span class="fc" id="L415">			return ObjectProductHandler.getProduct(source);</span>
		}
	}

	/**
	 * Get a product from storage, loading all file contents into memory.
	 *
	 * This method may cause memory problems if product contents are large.
	 *
	 * @param id
	 *            the product to retrieve.
	 * @return the loaded product.
	 * @throws Exception if error occurs
	 */
	public Product getInMemoryProduct(ProductId id) throws Exception {
<span class="nc" id="L430">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquiring read lock for product id=&quot;</span>
<span class="nc" id="L431">				+ id.toString());</span>
<span class="nc" id="L432">		storageLocks.acquireReadLock(id);</span>
<span class="nc" id="L433">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquired read lock for product id=&quot;</span>
<span class="nc" id="L434">				+ id.toString());</span>
		try {
			// load product
<span class="nc" id="L437">			Product product = getProduct(id);</span>
			// convert all contents to ByteContent
<span class="nc" id="L439">			Map&lt;String, Content&gt; contents = product.getContents();</span>
<span class="nc" id="L440">			Iterator&lt;String&gt; iter = contents.keySet().iterator();</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">			while (iter.hasNext()) {</span>
<span class="nc" id="L442">				String path = iter.next();</span>
<span class="nc" id="L443">				contents.put(path, new ByteContent(contents.get(path)));</span>
<span class="nc" id="L444">			}</span>
			// product content is all in memory
<span class="nc" id="L446">			return product;</span>
		} finally {
<span class="nc" id="L448">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="nc" id="L449">					+ &quot;] releasing read lock for product id=&quot; + id.toString());</span>
<span class="nc" id="L450">			storageLocks.releaseReadLock(id);</span>
<span class="nc" id="L451">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="nc" id="L452">					+ &quot;] released write lock for product id=&quot; + id.toString());</span>
		}
	}

	/**
	 * Get a ProductSource from storage.
	 *
	 * @param id
	 *            the product to retrieve.
	 * @return a ProductSource for the product, or null if not in this storage.
	 */
	public ProductSource getProductSource(ProductId id) throws Exception {
<span class="fc" id="L464">		ProductSource productSource = null;</span>

<span class="fc" id="L466">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquiring read lock for product id=&quot;</span>
<span class="fc" id="L467">				+ id.toString());</span>
		// acquire lock in case storage operation in progress
<span class="fc" id="L469">		storageLocks.acquireReadLock(id);</span>
<span class="fc" id="L470">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquired read lock for product id=&quot;</span>
<span class="fc" id="L471">				+ id.toString());</span>
		try {
<span class="fc" id="L473">			File productFile = getProductFile(id);</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">			if (productFile.exists()) {</span>
<span class="fc" id="L475">				productSource = getProductSourceFormat(productFile);</span>
			}
<span class="fc bfc" id="L477" title="All 2 branches covered.">			if (productSource == null) {</span>
<span class="fc" id="L478">				Iterator&lt;ProductStorage&gt; legacyIter = legacyStorages.iterator();</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">				while (legacyIter.hasNext()) {</span>
<span class="nc" id="L480">					ProductStorage next = legacyIter.next();</span>
					try {
<span class="nc" id="L482">						productSource = next.getProductSource(id);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">						if (productSource != null) {</span>
<span class="nc" id="L484">							break;</span>
						}
<span class="nc" id="L486">					} catch (Exception e) {</span>
<span class="nc" id="L487">						LOGGER.log(Level.FINE, &quot;[&quot; + getName() + &quot;] &quot; +</span>
								&quot;legacy storage getProductSource exception &quot;, e);
<span class="nc" id="L489">					}</span>
<span class="nc" id="L490">				}</span>
			}
		} finally {
			// release the lock no matter what
<span class="fc" id="L494">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L495">					+ &quot;] releasing read lock for product id=&quot; + id.toString());</span>
<span class="fc" id="L496">			storageLocks.releaseReadLock(id);</span>
<span class="fc" id="L497">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L498">					+ &quot;] released read lock for product id=&quot; + id.toString());</span>
		}

<span class="fc" id="L501">		return productSource;</span>
	}

	/**
	 * Check whether a product exists in storage.
	 *
	 * @param id
	 *            the product to check.
	 * @return true if the product exists, false otherwise.
	 */
	public boolean hasProduct(ProductId id) throws Exception {
<span class="fc" id="L512">		boolean hasProduct = false;</span>

<span class="fc" id="L514">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquiring read lock for product id=&quot;</span>
<span class="fc" id="L515">				+ id.toString());</span>
		// acquire lock in case storage operation in progress
<span class="fc" id="L517">		storageLocks.acquireReadLock(id);</span>
<span class="fc" id="L518">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquired read lock for product id=&quot;</span>
<span class="fc" id="L519">				+ id.toString());</span>
		try {
<span class="fc" id="L521">			File productDirectory = getProductFile(id);</span>
<span class="fc" id="L522">			hasProduct = productDirectory.exists();</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">			if (hasProduct) {</span>
				// be a little more detailed...
<span class="fc" id="L525">				ProductSource source = getProductSource(id);</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">				if (source == null) {</span>
<span class="nc" id="L527">					hasProduct = false;</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">				} else if (source instanceof DirectoryProductSource) {</span>
					// not sure how we would get here
					// FileNotFound exception appears in logs...
<span class="fc" id="L531">					hasProduct = (new File(productDirectory,</span>
							DirectoryProductHandler.PRODUCT_XML_FILENAME)
<span class="fc" id="L533">							.exists());</span>
				}
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">				if (source != null) {</span>
<span class="fc" id="L536">					source.close();</span>
				}
			}

<span class="fc bfc" id="L540" title="All 2 branches covered.">			if (!hasProduct) {</span>
				// primary storage doesn't have product, check legacy storages
<span class="fc" id="L542">				Iterator&lt;ProductStorage&gt; legacyIter = legacyStorages.iterator();</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">				while (legacyIter.hasNext()) {</span>
<span class="fc" id="L544">					ProductStorage next = legacyIter.next();</span>
					try {
<span class="fc bfc" id="L546" title="All 2 branches covered.">						if (next.hasProduct(id)) {</span>
<span class="fc" id="L547">							return true;</span>
						}
<span class="nc" id="L549">					} catch (Exception e) {</span>
<span class="nc" id="L550">						LOGGER.log(Level.FINE, &quot;[&quot; + getName()</span>
								+ &quot;] legacy storage hasProduct exception &quot;, e);
<span class="fc" id="L552">					}</span>
<span class="fc" id="L553">				}</span>
			}
		} finally {
<span class="fc" id="L556">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L557">					+ &quot;] releasing read lock for product id=&quot; + id.toString());</span>
			// release lock no matter what
<span class="fc" id="L559">			storageLocks.releaseReadLock(id);</span>
<span class="fc" id="L560">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L561">					+ &quot;] released read lock for product id=&quot; + id.toString());</span>
		}

<span class="fc" id="L564">		return hasProduct;</span>
	}

	/**
	 * Remove a product from storage.
	 *
	 * @param id
	 *            product to remove.
	 */
	public void removeProduct(ProductId id) throws Exception {
<span class="fc" id="L574">		String idString = id.toString();</span>
<span class="fc" id="L575">		LOGGER.finest(&quot;[&quot; + getName()</span>
				+ &quot;] acquiring write lock for product id=&quot; + idString);
		// acquire lock in case storage operation in progress
<span class="fc" id="L578">		storageLocks.acquireWriteLock(id);</span>
<span class="fc" id="L579">		LOGGER.finest(&quot;[&quot; + getName() + &quot;] acquired write lock for product id=&quot;</span>
				+ idString);
		try {
<span class="fc" id="L582">			File productFile = getProductFile(id);</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">			if (productFile.exists()) {</span>
				// recursively delete the product directory
<span class="fc" id="L585">				FileUtils.deleteTree(productFile);</span>
				// remove any empty parent directories
<span class="fc" id="L587">				FileUtils.deleteEmptyParents(productFile, baseDirectory);</span>
<span class="fc" id="L588">				LOGGER.finer(&quot;[&quot; + getName() + &quot;] product removed, id=&quot; + idString);</span>
			}
<span class="fc" id="L590">			productFile = null;</span>
			// remove from any legacy storages
<span class="fc" id="L592">			Iterator&lt;ProductStorage&gt; legacyIter = legacyStorages.iterator();</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">			while (legacyIter.hasNext()) {</span>
<span class="fc" id="L594">				ProductStorage next = legacyIter.next();</span>
				try {
<span class="fc" id="L596">					next.removeProduct(id);</span>
<span class="nc" id="L597">				} catch (Exception e) {</span>
<span class="nc" id="L598">					LOGGER.log(Level.FINE, &quot;[&quot; + getName()</span>
							+ &quot;] legacy storage remove exception &quot;, e);
<span class="fc" id="L600">				}</span>
<span class="fc" id="L601">			}</span>
		} finally {
<span class="fc" id="L603">			LOGGER.finest(&quot;[&quot; + getName()</span>
					+ &quot;] releasing write lock for product id=&quot; + idString);
			// release lock no matter what
<span class="fc" id="L606">			storageLocks.releaseWriteLock(id);</span>
<span class="fc" id="L607">			LOGGER.finest(&quot;[&quot; + getName()</span>
					+ &quot;] released write lock for product id=&quot; + idString);
		}

		// Notify listeners
<span class="fc" id="L612">		notifyListeners(new StorageEvent(this, id, StorageEvent.PRODUCT_REMOVED));</span>
<span class="fc" id="L613">	}</span>

	/**
	 * Store a product in storage.
	 *
	 * Same as storeProductSource(new ObjectProductSource(product)).
	 *
	 * @param product
	 *            the product to store.
	 * @return the id of the stored product.
	 */
	public ProductId storeProduct(Product product) throws Exception {
<span class="fc" id="L625">		return storeProductSource(new ObjectProductSource(product));</span>
	}

	/**
	 * Store a ProductSource to storage.
	 *
	 * If any exceptions occur while storing a product (other than the product
	 * already existing in storage) the incompletely stored product is removed.
	 *
	 * @param source
	 *            the ProductSource to store.
	 * @return the id of the stored product.
	 */
	public ProductId storeProductSource(ProductSource source) throws Exception {
<span class="fc" id="L639">		StorageProductOutput output = new StorageProductOutput();</span>
		// output acquires the storageLock during onBeginProduct, once the
		// product id is known.
		try {
<span class="fc" id="L643">			source.streamTo(output);</span>
			// close output so file(s) are written
<span class="fc" id="L645">			output.close();</span>

<span class="fc" id="L647">			ProductId id = output.getProductId();</span>
<span class="fc" id="L648">			LOGGER.finer(&quot;[&quot; + getName() + &quot;] product stored id=&quot; + id</span>
<span class="fc" id="L649">					+ &quot;, status=&quot; + output.getStatus());</span>

<span class="fc" id="L651">			verifier.verifySignature(getProduct(id));</span>

<span class="fc" id="L653">		} catch (Exception e) {</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">			if (!(e instanceof ProductAlreadyInStorageException)</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">					&amp;&amp; !(e.getCause() instanceof ProductAlreadyInStorageException)) {</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">				if (e instanceof InvalidSignatureException) {</span>
					// suppress stack trace for invalid signature
<span class="fc" id="L658">					LOGGER.warning(e.getMessage()</span>
							+ &quot;, removing incomplete product&quot;);
				} else {
<span class="nc" id="L661">					LOGGER.log(</span>
							Level.WARNING,
							&quot;[&quot;
<span class="nc" id="L664">									+ getName()</span>
									+ &quot;] exception while storing product, removing incomplete product&quot;,
							e);
				}
				try {
					// remove incompletely stored product.
<span class="fc" id="L670">					removeProduct(output.getProductId());</span>
<span class="nc" id="L671">				} catch (Exception e2) {</span>
					// ignore
<span class="nc" id="L673">					LOGGER.log(Level.WARNING, &quot;[&quot; + getName()</span>
							+ &quot;] exception while removing incomplete product&quot;,
							e2);
<span class="fc" id="L676">				}</span>
			}
<span class="fc" id="L678">			throw e;</span>
		} finally {
			// DO RELEASE THE WRITE LOCK HERE

			// This leads to thread sync problems in
			// SearchResponseXmlProductSource, because xml events were sent in
			// one thread, leading to acquisition of a write lock, while this
			// method was called in a separate thread and attempted to release
			// the write lock.

			// However, not releasing the lock here leads to other problems when
			// hubs are receiving products via multiple receivers.

<span class="fc" id="L691">			ProductId id = output.getProductId();</span>

<span class="pc bpc" id="L693" title="1 of 2 branches missed.">			if (id != null) {</span>
				// release the write lock
<span class="fc" id="L695">				LOGGER.finest(&quot;[&quot; + getName()</span>
						+ &quot;] releasing write lock for product id=&quot;
<span class="fc" id="L697">						+ id.toString());</span>
<span class="fc" id="L698">				storageLocks.releaseWriteLock(id);</span>
<span class="fc" id="L699">				LOGGER.finest(&quot;[&quot; + getName()</span>
						+ &quot;] released write lock for product id=&quot;
<span class="fc" id="L701">						+ id.toString());</span>
			}

			// close underlying handler
<span class="fc" id="L705">			output.close();</span>
<span class="fc" id="L706">			output.setProductOutput(null);</span>

<span class="fc" id="L708">			source.close();</span>
		}

<span class="fc" id="L711">		ProductId id = output.getProductId();</span>
		// Notify our storage listeners
<span class="fc" id="L713">		StorageEvent event = new StorageEvent(this, id,</span>
				StorageEvent.PRODUCT_STORED);
<span class="fc" id="L715">		notifyListeners(event);</span>

<span class="fc" id="L717">		return id;</span>
	}

	/**
	 * Used when storing products.
	 *
	 * When onBeginProduct is called with the ProductId being stored, a
	 * DirectoryProductOutput is created which manages storage.
	 */
	private class StorageProductOutput extends FilterProductHandler {

		/** The stored product id. */
		private ProductId id;

		/** The stored product status. */
		private String status;

		/**
		 * Construct a new StorageProductOutput.
		 */
<span class="fc" id="L737">		public StorageProductOutput() {</span>
<span class="fc" id="L738">		}</span>

		/**
		 * @return the product id that was stored.
		 */
		public ProductId getProductId() {
<span class="fc" id="L744">			return id;</span>
		}

		/**
		 * @return the product status that was stored.
		 */
		public String getStatus() {
<span class="fc" id="L751">			return status;</span>
		}

		/**
		 * The productID is stored and can be found using getProductId().
		 */
		public void onBeginProduct(ProductId id, String status, URL trackerURL)
				throws Exception {
			// save the product id for later
<span class="fc" id="L760">			this.id = id;</span>
<span class="fc" id="L761">			this.status = status;</span>

			// acquire write lock for product
<span class="fc" id="L764">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L765">					+ &quot;] acquiring write lock for product id=&quot; + id.toString());</span>
<span class="fc" id="L766">			storageLocks.acquireWriteLock(id);</span>
			// keep track that we have write lock
<span class="fc" id="L768">			LOGGER.finest(&quot;[&quot; + getName()</span>
<span class="fc" id="L769">					+ &quot;] acquired write lock for product id=&quot; + id.toString());</span>
<span class="fc bfc" id="L770" title="All 2 branches covered.">			if (hasProduct(id)) {</span>
<span class="fc" id="L771">				throw new ProductAlreadyInStorageException(&quot;[&quot; + getName()</span>
						+ &quot;] product already in storage&quot;);
			}

			// set the wrapped product output
<span class="fc" id="L776">			setProductOutput(getProductHandlerFormat(getProductFile(id)));</span>
			// call the directory product output onBeginProduct method to start
			// writing the product
<span class="fc" id="L779">			super.onBeginProduct(id, status, trackerURL);</span>
<span class="fc" id="L780">		}</span>

		public void onEndProduct(ProductId id) throws Exception {
			// call the directory product output onEndProduct method to finish
			// writing the product
<span class="fc" id="L785">			super.onEndProduct(id);</span>

			// DONT RELEASE THE LOCK HERE, this causes bigger problems on
			// hubs...

			// release the write lock
			// LOGGER.finest(&quot;Releasing write lock for product id=&quot; +
			// id.toString());
			// storageLocks.releaseWriteLock(id);
			// keep track that we no longer have write lock
			// this.haveWriteLock = false;
			// LOGGER.finest(&quot;Released write lock for product id=&quot; +
			// id.toString());
<span class="fc" id="L798">		}</span>
	}

	/**
	 * Called at client shutdown to free resources.
	 */
	public void shutdown() throws Exception {
		// Remove all our listeners. Doing this will also shut down the
		// ExecutorServices
<span class="fc" id="L807">		Iterator&lt;StorageListener&gt; listenerIter = listeners.keySet().iterator();</span>
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">		while (listenerIter.hasNext()) {</span>
<span class="nc" id="L809">			removeStorageListener(listenerIter.next());</span>
			// Maybe we should call &quot;listener.shutdown()&quot; here as well?
		}

		// shutdown any legacy storages
<span class="fc" id="L814">		Iterator&lt;ProductStorage&gt; legacyIter = legacyStorages.iterator();</span>
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">		while (legacyIter.hasNext()) {</span>
<span class="nc" id="L816">			ProductStorage next = legacyIter.next();</span>
			try {
<span class="nc" id="L818">				next.shutdown();</span>
<span class="nc" id="L819">			} catch (Exception e) {</span>
<span class="nc" id="L820">				LOGGER.log(Level.FINE, &quot;[&quot; + getName()</span>
						+ &quot;] legacy storage shutdown exception &quot;, e);
<span class="nc" id="L822">			}</span>
<span class="nc" id="L823">		}</span>
<span class="fc" id="L824">	}</span>

	/**
	 * Called after client configuration to begin processing.
	 */
	public void startup() throws Exception {
		// startup any legacy storages
<span class="fc" id="L831">		Iterator&lt;ProductStorage&gt; legacyIter = legacyStorages.iterator();</span>
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">		while (legacyIter.hasNext()) {</span>
<span class="nc" id="L833">			ProductStorage next = legacyIter.next();</span>
			try {
<span class="nc" id="L835">				next.startup();</span>
<span class="nc" id="L836">			} catch (Exception e) {</span>
<span class="nc" id="L837">				LOGGER.log(Level.FINE, &quot;[&quot; + getName()</span>
						+ &quot;] legacy storage startup exception &quot;, e);
<span class="nc" id="L839">			}</span>
<span class="nc" id="L840">		}</span>
<span class="fc" id="L841">	}</span>

	/**
	 * @return the baseDirectory
	 */
	public File getBaseDirectory() {
<span class="fc" id="L847">		return baseDirectory;</span>
	}

	/**
	 * @param baseDirectory
	 *            the baseDirectory to set
	 */
	public void setBaseDirectory(File baseDirectory) {
<span class="nc" id="L855">		this.baseDirectory = baseDirectory;</span>
<span class="nc" id="L856">	}</span>

	/**
	 * @return the rejectInvalidSignatures
	 */
	public boolean isRejectInvalidSignatures() {
<span class="nc" id="L862">		return verifier.isRejectInvalidSignatures();</span>
	}

	/**
	 * @param rejectInvalidSignatures
	 *            the rejectInvalidSignatures to set
	 */
	public void setRejectInvalidSignatures(boolean rejectInvalidSignatures) {
<span class="fc" id="L870">		verifier.setRejectInvalidSignatures(rejectInvalidSignatures);</span>
<span class="fc" id="L871">	}</span>

	/**
	 * @return the testSignatures
	 */
	public boolean isTestSignatures() {
<span class="nc" id="L877">		return verifier.isTestSignatures();</span>
	}

	/**
	 * @param testSignatures
	 *            the testSignatures to set
	 */
	public void setTestSignatures(boolean testSignatures) {
<span class="fc" id="L885">		verifier.setTestSignatures(testSignatures);</span>
<span class="fc" id="L886">	}</span>

	/**
	 * @return the keychain
	 */
	public ProductKeyChain getKeychain() {
<span class="nc" id="L892">		return verifier.getKeychain();</span>
	}

	/**
	 * @param keychain
	 *            the keychain to set
	 */
	public void setKeychain(ProductKeyChain keychain) {
<span class="fc" id="L900">		verifier.setKeychain(keychain);</span>
<span class="fc" id="L901">	}</span>

	/**
	 * @return the legacyStorages.
	 */
	public List&lt;ProductStorage&gt; getLegacyStorages() {
<span class="fc" id="L907">		return legacyStorages;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>