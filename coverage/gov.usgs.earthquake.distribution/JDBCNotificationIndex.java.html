<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JDBCNotificationIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.earthquake.distribution</a> &gt; <span class="el_source">JDBCNotificationIndex.java</span></div><h1>JDBCNotificationIndex.java</h1><pre class="source lang-java linenums">/*
 * JDBCNotificationIndex
 */
package gov.usgs.earthquake.distribution;

import gov.usgs.earthquake.product.ProductId;
import gov.usgs.earthquake.util.JDBCConnection;
import gov.usgs.util.Config;
import gov.usgs.util.StreamUtils;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Logger;

/**
 * Stores and retrieves Notifications.
 *
 * This is typically used by a NotificationReceiver to track its Notifications,
 * but may also be used by NotificationListeners. Each object should maintain a
 * separate NotificationIndex.
 *
 * This implementation uses a SQLite Database as the index.
 *
 * @see gov.usgs.earthquake.distribution.NotificationIndex
 */
public class JDBCNotificationIndex extends JDBCConnection implements
		NotificationIndex {

<span class="fc" id="L39">	private static final Logger LOGGER = Logger</span>
<span class="fc" id="L40">			.getLogger(JDBCNotificationIndex.class.getName());</span>

	/**
	 * Default (empty) DB Schema SQLite file for the index. If the configured
	 * index file does not exist in the file system at the time this instance's
	 * &quot;startup()&quot; method is called, then this file is copied out of the JAR
	 * file into the file system as configured.
	 *
	 * The schema contained in this file is very simple:
	 *
	 * CREATE TABLE notification_index ( id INTEGER PRIMARY KEY NOT NULL,
	 * product_source TEXT NOT NULL, product_type TEXT NOT NULL, product_code
	 * TEXT NOT NULL, product_update LONG NOT NULL, expiration_date LONG NOT
	 * NULL, tracker_url TEXT NOT NULL, product_url TEXT );
	 *
	 * CREATE TABLE tmp_lookup_table ( product_source TEXT, product_type TEXT,
	 * product_code TEXT);
	 *
	 * CREATE INDEX expired_index on notification_index (expiration_date);
	 * CREATE INDEX id_index on notification_index (product_source,
	 * product_type, product_code, product_update);
	 *
	 * CREATE TABLE notification_queue ( id INTEGER PRIMARY KEY NOT NULL,
	 * queue_name TEXT NOT NULL, product_source TEXT NOT NULL, product_type TEXT
	 * NOT NULL, product_code TEXT NOT NULL, product_update LONG NOT NULL );
	 *
	 * CREATE INDEX queue_index on notification_queue (queue_name,
	 * product_source, product_type, product_code, product_update);
	 *
	 */
	private static final String JDBC_DB_SCHEMA = &quot;etc/schema/notificationIndex.db&quot;;

	// The following variables reference database information and are used for
	// binding/fetching query parameters in the prepared statements
	private static final String TABLE_NAME = &quot;notification_index&quot;;
	private static final String TMP_TABLE = &quot;tmp_lookup_table&quot;;
	private static final String ID_COLUMN = &quot;id&quot;;
	private static final String PRODUCT_SOURCE_COLUMN = &quot;product_source&quot;;
	private static final String PRODUCT_TYPE_COLUMN = &quot;product_type&quot;;
	private static final String PRODUCT_CODE_COLUMN = &quot;product_code&quot;;
	private static final String PRODUCT_UPDATE_COLUMN = &quot;product_update&quot;;
	private static final String EXPIRATION_DATE_COLUMN = &quot;expiration_date&quot;;
	private static final String TRACKER_URL_COLUMN = &quot;tracker_url&quot;;
	private static final String PRODUCT_URL_COLUMN = &quot;product_url&quot;;

	// SQLite driver information
	/** SQLite driver class name. */
	private static final String JDBC_DRIVER_CLASS = &quot;org.sqlite.JDBC&quot;;
	/** SQLite connect url without a filename. */
	private static final String JDBC_CONNECT_URL = &quot;jdbc:sqlite:&quot;;
	/** Default SQLite database filename. */
	private static final String JDBC_DEFAULT_FILE = &quot;pd_index.db&quot;;

	/**
	 * This is the property key used in the configuration file to specify a
	 * different SQLite database file. If this file doesn't exist it will be
	 * created at startup time
	 */
	protected static final String JDBC_FILE_PROPERTY = &quot;indexfile&quot;;

	/** SQL stub for adding a notification to the index. */
<span class="fc" id="L101">	private static final String DML_ADD_NOTIFICATION = String.format(</span>
			&quot;INSERT INTO %s (%s, %s, %s, %s, %s, %s, %s) VALUES &quot;
					+ &quot;(?, ?, ?, ?, ?, ?, ?)&quot;, TABLE_NAME,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN,
			PRODUCT_URL_COLUMN);

	/** SQL stub for removing a notification from the index. */
<span class="fc" id="L109">	private static final String DML_REMOVE_NOTIFICATION = String.format(</span>
			&quot;DELETE FROM %s WHERE %s = ? AND %s = ? AND %s = ? &quot;
					+ &quot;AND %s = ? AND %s = ? AND %s = ? AND %s = ?&quot;,
			TABLE_NAME, PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN,
			PRODUCT_CODE_COLUMN, PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
			TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN);

	/** SQL stub for finding expired notifications. */
<span class="fc" id="L117">	private static final String QUERY_FIND_EXPIRED_NOTIFICATIONS = String</span>
<span class="fc" id="L118">			.format(&quot;SELECT %s, %s, %s, %s, %s, %s, %s, %s FROM %s &quot;</span>
					+ &quot;WHERE %s &lt;= ?&quot;, ID_COLUMN, PRODUCT_SOURCE_COLUMN,
					PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
					PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
					TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN, TABLE_NAME,
					EXPIRATION_DATE_COLUMN);

	/** SQL stub for finding notifications about a particular productId */
<span class="fc" id="L126">	private static final String QUERY_FIND_NOTIFICATIONS_BY_ID = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s, %s FROM %s &quot;
					+ &quot;WHERE %s = ? AND %s = ? AND %s = ? AND %s = ?&quot;,
			ID_COLUMN, PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN,
			PRODUCT_CODE_COLUMN, PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
			TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN, TABLE_NAME,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN);

	/**
	 * SQL stub for finding notifications about products based on discrete data.
	 */
<span class="fc" id="L138">	private static final String QUERY_FIND_NOTIFICATIONS_BY_DATA = String</span>
<span class="fc" id="L139">			.format(&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE &quot;</span>
					+ &quot;UPPER(%s) LIKE ? AND UPPER(%s) LIKE ? AND &quot;
					+ &quot;UPPER(%s) LIKE ?&quot;, PRODUCT_SOURCE_COLUMN,
					PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
					PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
					TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN, TABLE_NAME,
					PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN,
					PRODUCT_CODE_COLUMN);

	/** Name of the SQLite DB file to use. This is configurable. */
<span class="fc" id="L149">	private String _jdbc_index_file = null;</span>

	/**
	 * Connection URL. Created from the JDBC_CONNET_URL and configured index
	 * file.
	 */
<span class="fc" id="L155">	private String _jdbc_connect_url = null;</span>

	// These are the prepared statements we will use for all DB interactions. //

<span class="fc" id="L159">	private PreparedStatement _dml_addNotification = null;</span>
<span class="fc" id="L160">	private PreparedStatement _dml_removeNotification = null;</span>

<span class="fc" id="L162">	private PreparedStatement _query_findExpiredNotifications = null;</span>
<span class="fc" id="L163">	private PreparedStatement _query_findNotificationsById = null;</span>
<span class="fc" id="L164">	private PreparedStatement _query_findNotificationsByData = null;</span>

	// Stubs used in the list version of find by data method. //
<span class="fc" id="L167">	private static final String DML_CREATE_TMP_TABLE = String.format(</span>
			&quot;CREATE TABLE IF NOT EXISTS %s (%s TEXT, %s TEXT, %s TEXT)&quot;,
			TMP_TABLE, PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN,
			PRODUCT_CODE_COLUMN);
<span class="fc" id="L171">	private static final String DML_ADD_TMP_SOURCE = String.format(</span>
			&quot;INSERT INTO %s (%s) VALUES (?)&quot;, TMP_TABLE, PRODUCT_SOURCE_COLUMN);
<span class="fc" id="L173">	private static final String DML_ADD_TMP_TYPE = String.format(</span>
			&quot;INSERT INTO %s (%s) VALUES (?)&quot;, TMP_TABLE, PRODUCT_TYPE_COLUMN);
<span class="fc" id="L175">	private static final String DML_ADD_TMP_CODE = String.format(</span>
			&quot;INSERT INTO %s (%s) VALUES (?)&quot;, TMP_TABLE, PRODUCT_CODE_COLUMN);

<span class="fc" id="L178">	private static final String QUERY_SEARCH_BY_SOURCE_TYPE_CODE = String</span>
<span class="fc" id="L179">			.format(&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;</span>
					+ &quot;(SELECT %s FROM %s) AND %s IN (SELECT %s FROM %s) AND &quot;
					+ &quot;%s IN (SELECT %s FROM %s)&quot;, PRODUCT_SOURCE_COLUMN,
					PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
					PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
					TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN, TABLE_NAME,
					PRODUCT_SOURCE_COLUMN, PRODUCT_SOURCE_COLUMN, TMP_TABLE,
					PRODUCT_TYPE_COLUMN, PRODUCT_TYPE_COLUMN, TMP_TABLE,
					PRODUCT_CODE_COLUMN, PRODUCT_CODE_COLUMN, TMP_TABLE);

<span class="fc" id="L189">	private static final String QUERY_SEARCH_BY_SOURCE_TYPE = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;
					+ &quot;(SELECT %s FROM %s) AND %s IN (SELECT %s FROM %s)&quot;,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN,
			PRODUCT_URL_COLUMN, TABLE_NAME, PRODUCT_SOURCE_COLUMN,
			PRODUCT_SOURCE_COLUMN, TMP_TABLE, PRODUCT_TYPE_COLUMN,
			PRODUCT_TYPE_COLUMN, TMP_TABLE);

<span class="fc" id="L198">	private static final String QUERY_SEARCH_BY_SOURCE_CODE = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;
					+ &quot;(SELECT %s FROM %s) AND %s IN (SELECT %s FROM %s)&quot;,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN,
			PRODUCT_URL_COLUMN, TABLE_NAME, PRODUCT_SOURCE_COLUMN,
			PRODUCT_SOURCE_COLUMN, TMP_TABLE, PRODUCT_CODE_COLUMN,
			PRODUCT_CODE_COLUMN, TMP_TABLE);

<span class="fc" id="L207">	private static final String QUERY_SEARCH_BY_TYPE_CODE = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;
					+ &quot;(SELECT %s FROM %s) AND %s IN (SELECT %s FROM %s)&quot;,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN,
			PRODUCT_URL_COLUMN, TABLE_NAME, PRODUCT_TYPE_COLUMN,
			PRODUCT_TYPE_COLUMN, TMP_TABLE, PRODUCT_CODE_COLUMN,
			PRODUCT_CODE_COLUMN, TMP_TABLE);

<span class="fc" id="L216">	private static final String QUERY_SEARCH_BY_SOURCE = String</span>
<span class="fc" id="L217">			.format(&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;</span>
					+ &quot;(SELECT %s FROM %s)&quot;, PRODUCT_SOURCE_COLUMN,
					PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
					PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN,
					TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN, TABLE_NAME,
					PRODUCT_SOURCE_COLUMN, PRODUCT_SOURCE_COLUMN, TMP_TABLE);

<span class="fc" id="L224">	private static final String QUERY_SEARCH_BY_TYPE = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;
					+ &quot;(SELECT %s FROM %s)&quot;, PRODUCT_SOURCE_COLUMN,
			PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN, PRODUCT_UPDATE_COLUMN,
			EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN,
			TABLE_NAME, PRODUCT_TYPE_COLUMN, PRODUCT_TYPE_COLUMN, TMP_TABLE);

<span class="fc" id="L231">	private static final String QUERY_SEARCH_BY_CODE = String.format(</span>
			&quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s WHERE %s IN &quot;
					+ &quot;(SELECT %s FROM %s)&quot;, PRODUCT_SOURCE_COLUMN,
			PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN, PRODUCT_UPDATE_COLUMN,
			EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN,
			TABLE_NAME, PRODUCT_CODE_COLUMN, PRODUCT_CODE_COLUMN, TMP_TABLE);
	/*
	 * private static final String QUERY_ALL_NOTIFICATIONS = String.format(
	 * &quot;SELECT %s, %s, %s, %s, %s, %s, %s FROM %s&quot;, PRODUCT_SOURCE_COLUMN,
	 * PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN, PRODUCT_UPDATE_COLUMN,
	 * EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN, PRODUCT_URL_COLUMN,
	 * TABLE_NAME);
	 */

<span class="fc" id="L245">	private static final String QUERY_LATEST_NOTIFICATIONS = String.format(</span>
			&quot;SELECT n.%s, n.%s, n.%s, n.%s, n.%s, n.%s, n.%s FROM %s n, &quot;
					+ &quot;(select max(id) as id, product_source, product_type, &quot;
					+ &quot;product_code, product_update from notification_index &quot;
					+ &quot;group by product_source, product_type, product_code, &quot;
					+ &quot;product_update) latest where n.id=latest.id &quot;
					+ &quot; order by n.product_update asc&quot;,
			PRODUCT_SOURCE_COLUMN, PRODUCT_TYPE_COLUMN, PRODUCT_CODE_COLUMN,
			PRODUCT_UPDATE_COLUMN, EXPIRATION_DATE_COLUMN, TRACKER_URL_COLUMN,
			PRODUCT_URL_COLUMN, TABLE_NAME);

	// These are for searching the DB index by specific parameters. */
<span class="fc" id="L257">	private PreparedStatement _dml_createTmpTable = null;</span>
<span class="fc" id="L258">	private PreparedStatement _dml_addTmpSource = null;</span>
<span class="fc" id="L259">	private PreparedStatement _dml_addTmpType = null;</span>
<span class="fc" id="L260">	private PreparedStatement _dml_addTmpCode = null;</span>

<span class="fc" id="L262">	private PreparedStatement _query_searchBySourceTypeCode = null;</span>
<span class="fc" id="L263">	private PreparedStatement _query_searchBySourceType = null;</span>
<span class="fc" id="L264">	private PreparedStatement _query_searchBySourceCode = null;</span>
<span class="fc" id="L265">	private PreparedStatement _query_searchByTypeCode = null;</span>
<span class="fc" id="L266">	private PreparedStatement _query_searchBySource = null;</span>
<span class="fc" id="L267">	private PreparedStatement _query_searchByType = null;</span>
<span class="fc" id="L268">	private PreparedStatement _query_searchByCode = null;</span>
<span class="fc" id="L269">	private PreparedStatement _query_getAllNotifications = null;</span>

	/**
	 * Default, no-arg constructor. This just ensures the JDBC SQLite driver is
	 * appropriately on the classpath for proper runtime execution. This
	 * probably will not get called directly in favor of the configurable
	 * constructor.
	 *
	 * @throws Exception
	 *             If the JDBC driver class is not found.
	 * @see #JDBC_DRIVER_CLASS
	 */
	public JDBCNotificationIndex() throws Exception {
<span class="fc" id="L282">		this((String) null);</span>
<span class="fc" id="L283">	}</span>

	/**
	 * Constructor call from filename, where filename is jdbc index file
	 * If null, then index file defaults
	 * @param filename String - What will be the index file
	 * @throws Exception if error occurs
	 */
<span class="fc" id="L291">	public JDBCNotificationIndex(final String filename) throws Exception {</span>
<span class="fc" id="L292">		Class.forName(JDBC_DRIVER_CLASS);</span>
<span class="fc" id="L293">		_jdbc_index_file = filename;</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">		if (_jdbc_index_file == null) {</span>
<span class="fc" id="L295">			_jdbc_index_file = JDBC_DEFAULT_FILE;</span>
		}
<span class="fc" id="L297">		_jdbc_connect_url = JDBC_CONNECT_URL + _jdbc_index_file;</span>
<span class="fc" id="L298">	}</span>

	/**
	 * Constructor called from the config object conforming to the
	 * &lt;code&gt;Configurable&lt;/code&gt; interface specification. This internally calls
	 * its no-arg constructor then configures itself.
	 *
	 * @param config
	 *            The config object from which this instance will be configured.
	 * @throws Exception
	 *             If the JDBC driver class is not found.
	 * @see gov.usgs.util.Configurable
	 * @see #JDBC_DRIVER_CLASS
	 */
	public JDBCNotificationIndex(Config config) throws Exception {
<span class="fc" id="L313">		this();</span>
<span class="fc" id="L314">		this.configure(config);</span>
<span class="fc" id="L315">	}</span>

	/**
	 * Reads the given &lt;code&gt;config&lt;/code&gt; object and sets values appropriately.
	 *
	 * @param config
	 *            The config object from which this instance will be configured.
	 * @see gov.usgs.util.Configurable
	 */
	public void configure(Config config) throws Exception {
<span class="fc" id="L325">		_jdbc_index_file = config.getProperty(JDBC_FILE_PROPERTY);</span>
<span class="pc bpc" id="L326" title="2 of 4 branches missed.">		if (_jdbc_index_file == null || &quot;&quot;.equals(_jdbc_index_file)) {</span>
<span class="nc" id="L327">			_jdbc_index_file = JDBC_DEFAULT_FILE;</span>
		}
<span class="fc" id="L329">		LOGGER.config(&quot;Notification index database is '&quot; + _jdbc_index_file</span>
				+ &quot;'&quot;);
<span class="fc" id="L331">		_jdbc_connect_url = JDBC_CONNECT_URL + _jdbc_index_file;</span>
<span class="fc" id="L332">	}</span>

	@Override
	protected Connection connect() throws Exception {
		// Make sure file exists or copy it out of the JAR
<span class="fc" id="L337">		File indexFile = new File(_jdbc_index_file);</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">		if (!indexFile.exists()) {</span>
			// extract schema from jar
<span class="fc" id="L340">			URL schemaURL = JDBCNotificationIndex.class.getClassLoader()</span>
<span class="fc" id="L341">					.getResource(JDBC_DB_SCHEMA);</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">			if (schemaURL == null) {</span>
<span class="fc" id="L343">				schemaURL = new File(JDBC_DB_SCHEMA).toURI().toURL();</span>
			}
<span class="fc" id="L345">			StreamUtils.transferStream(schemaURL, indexFile);</span>
		}

<span class="fc" id="L348">		return DriverManager.getConnection(_jdbc_connect_url);</span>
	}

	/**
	 * Connects to the JDBC DB index and prepares the DML/Query statements that
	 * will execute at runtime. If the JDBC DB index file does not exist then an
	 * empty schema will be copied out of the executing JAR file to be used.
	 *
	 * @see gov.usgs.util.Configurable
	 */
	public void startup() throws Exception {
		// call super startup to connect
<span class="fc" id="L360">		super.startup();</span>
<span class="fc" id="L361">		Connection conn = getConnection();</span>

		// prepare statements
<span class="fc" id="L364">		_dml_addNotification = conn.prepareStatement(DML_ADD_NOTIFICATION);</span>
<span class="fc" id="L365">		_dml_removeNotification = conn</span>
<span class="fc" id="L366">				.prepareStatement(DML_REMOVE_NOTIFICATION);</span>

<span class="fc" id="L368">		_query_findExpiredNotifications = conn</span>
<span class="fc" id="L369">				.prepareStatement(QUERY_FIND_EXPIRED_NOTIFICATIONS);</span>
<span class="fc" id="L370">		_query_findNotificationsById = conn</span>
<span class="fc" id="L371">				.prepareStatement(QUERY_FIND_NOTIFICATIONS_BY_ID);</span>
<span class="fc" id="L372">		_query_findNotificationsByData = conn</span>
<span class="fc" id="L373">				.prepareStatement(QUERY_FIND_NOTIFICATIONS_BY_DATA);</span>

<span class="fc" id="L375">		_dml_createTmpTable = conn.prepareStatement(DML_CREATE_TMP_TABLE);</span>
<span class="fc" id="L376">		_dml_addTmpSource = conn.prepareStatement(DML_ADD_TMP_SOURCE);</span>
<span class="fc" id="L377">		_dml_addTmpType = conn.prepareStatement(DML_ADD_TMP_TYPE);</span>
<span class="fc" id="L378">		_dml_addTmpCode = conn.prepareStatement(DML_ADD_TMP_CODE);</span>

<span class="fc" id="L380">		_query_searchBySourceTypeCode = conn</span>
<span class="fc" id="L381">				.prepareStatement(QUERY_SEARCH_BY_SOURCE_TYPE_CODE);</span>
<span class="fc" id="L382">		_query_searchBySourceType = conn</span>
<span class="fc" id="L383">				.prepareStatement(QUERY_SEARCH_BY_SOURCE_TYPE);</span>
<span class="fc" id="L384">		_query_searchBySourceCode = conn</span>
<span class="fc" id="L385">				.prepareStatement(QUERY_SEARCH_BY_SOURCE_CODE);</span>
<span class="fc" id="L386">		_query_searchByTypeCode = conn</span>
<span class="fc" id="L387">				.prepareStatement(QUERY_SEARCH_BY_TYPE_CODE);</span>
<span class="fc" id="L388">		_query_searchBySource = conn.prepareStatement(QUERY_SEARCH_BY_SOURCE);</span>
<span class="fc" id="L389">		_query_searchByType = conn.prepareStatement(QUERY_SEARCH_BY_TYPE);</span>
<span class="fc" id="L390">		_query_searchByCode = conn.prepareStatement(QUERY_SEARCH_BY_CODE);</span>
<span class="fc" id="L391">		_query_getAllNotifications = conn</span>
<span class="fc" id="L392">				.prepareStatement(QUERY_LATEST_NOTIFICATIONS);</span>

<span class="fc" id="L394">	}</span>

	/**
	 * Closes the JDBC connection and all it's associated prepared statements.
	 *
	 * @see gov.usgs.util.Configurable
	 */
	public synchronized void shutdown() throws Exception {
		// Close the DML statements
		try {
<span class="fc" id="L404">			_dml_addNotification.close();</span>
<span class="fc" id="L405">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L407">			_dml_addNotification = null;</span>
		}
		try {
<span class="fc" id="L410">			_dml_removeNotification.close();</span>
<span class="fc" id="L411">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L413">			_dml_removeNotification = null;</span>
		}
		try {
<span class="fc" id="L416">			_dml_createTmpTable.close();</span>
<span class="fc" id="L417">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L419">			_dml_createTmpTable = null;</span>
		}
		try {
<span class="fc" id="L422">			_dml_addTmpSource.close();</span>
<span class="fc" id="L423">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L425">			_dml_addTmpSource = null;</span>
		}
		try {
<span class="fc" id="L428">			_dml_addTmpType.close();</span>
<span class="fc" id="L429">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L431">			_dml_addTmpType = null;</span>
		}
		try {
<span class="fc" id="L434">			_dml_addTmpCode.close();</span>
<span class="fc" id="L435">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L437">			_dml_addTmpCode = null;</span>
		}

		// Close the query statements
		try {
<span class="fc" id="L442">			_query_findExpiredNotifications.close();</span>
<span class="fc" id="L443">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L445">			_query_findExpiredNotifications = null;</span>
		}
		try {
<span class="fc" id="L448">			_query_findNotificationsById.close();</span>
<span class="fc" id="L449">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L451">			_query_findNotificationsById = null;</span>
		}
		try {
<span class="fc" id="L454">			_query_findNotificationsByData.close();</span>
<span class="fc" id="L455">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L457">			_query_findNotificationsByData = null;</span>
		}
		try {
<span class="fc" id="L460">			_query_searchBySourceTypeCode.close();</span>
<span class="fc" id="L461">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L463">			_query_searchBySourceTypeCode = null;</span>
		}
		try {
<span class="fc" id="L466">			_query_searchBySourceType.close();</span>
<span class="fc" id="L467">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L469">			_query_searchBySourceType = null;</span>
		}
		try {
<span class="fc" id="L472">			_query_searchBySourceCode.close();</span>
<span class="fc" id="L473">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L475">			_query_searchBySourceCode = null;</span>
		}
		try {
<span class="fc" id="L478">			_query_searchByTypeCode.close();</span>
<span class="fc" id="L479">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L481">			_query_searchByTypeCode = null;</span>
		}
		try {
<span class="fc" id="L484">			_query_searchBySource.close();</span>
<span class="fc" id="L485">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L487">			_query_searchBySource = null;</span>
		}
		try {
<span class="fc" id="L490">			_query_searchByType.close();</span>
<span class="fc" id="L491">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L493">			_query_searchByType = null;</span>
		}
		try {
<span class="fc" id="L496">			_query_searchByCode.close();</span>
<span class="fc" id="L497">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L499">			_query_searchByCode = null;</span>
		}
		try {
<span class="fc" id="L502">			_query_getAllNotifications.close();</span>
<span class="fc" id="L503">		} catch (Exception e) {</span>
		} finally {
<span class="fc" id="L505">			_query_getAllNotifications = null;</span>
		}

		// call super shutdown to disconnect
<span class="fc" id="L509">		super.shutdown();</span>
<span class="fc" id="L510">	}</span>

	/**
	 * Add a notification to the index.
	 *
	 * If an identical notification is already in the index, the implementation
	 * may choose whether or not to store the duplicate information.
	 *
	 * @param notification
	 *            the notification to add.
	 * @throws Exception
	 *             if an error occurs while storing the notification.
	 * @see gov.usgs.earthquake.distribution.NotificationIndex
	 */
	public synchronized void addNotification(Notification notification)
			throws Exception {
		// verify connection
<span class="fc" id="L527">		this.verifyConnection();</span>

		// Read the product id from the notification
<span class="fc" id="L530">		ProductId productId = notification.getProductId();</span>

		// Parse the update date from the product id
<span class="fc" id="L533">		java.sql.Date updateDate = new java.sql.Date(productId.getUpdateTime()</span>
<span class="fc" id="L534">				.getTime());</span>

		// Parse the expiration date from the notification
<span class="fc" id="L537">		java.sql.Date expirationDate = new java.sql.Date(notification</span>
<span class="fc" id="L538">				.getExpirationDate().getTime());</span>

		// Read the URL value from the notification
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">		String trackerUrl = notification.getTrackerURL() != null</span>
<span class="fc" id="L542">				? notification.getTrackerURL().toString()</span>
<span class="pc" id="L543">				: &quot;&quot;;</span>

		// Set the values we parsed above
<span class="fc" id="L546">		_dml_addNotification.setString(1, productId.getSource());</span>
<span class="fc" id="L547">		_dml_addNotification.setString(2, productId.getType());</span>
<span class="fc" id="L548">		_dml_addNotification.setString(3, productId.getCode());</span>
<span class="fc" id="L549">		_dml_addNotification.setDate(4, updateDate);</span>
<span class="fc" id="L550">		_dml_addNotification.setDate(5, expirationDate);</span>
<span class="fc" id="L551">		_dml_addNotification.setString(6, trackerUrl);</span>

		// If this is a URL notification, set the product URL value as well
<span class="fc bfc" id="L554" title="All 2 branches covered.">		if (notification instanceof URLNotification) {</span>
<span class="fc" id="L555">			String productUrl = ((URLNotification) notification)</span>
<span class="fc" id="L556">					.getProductURL().toString();</span>
<span class="fc" id="L557">			_dml_addNotification.setString(7, productUrl);</span>
<span class="fc" id="L558">		} else {</span>
<span class="fc" id="L559">			_dml_addNotification.setString(7, &quot;&quot;);</span>
		}

		// already verified above
<span class="fc" id="L563">		Connection conn = getConnection();</span>
		try {
			// Begin a transaction
<span class="fc" id="L566">			conn.setAutoCommit(false);</span>
			// Execute the query
<span class="fc" id="L568">			_dml_addNotification.executeUpdate();</span>
			// Commit the changes
<span class="fc" id="L570">			conn.setAutoCommit(true);</span>
<span class="nc" id="L571">		} catch (SQLException sqx) {</span>
			// Undo any changes that may be in an unknown state. Ignore
			// exceptions that occur in this call since we're already throwing
			// an exception
			try {
<span class="nc" id="L576">				conn.rollback();</span>
<span class="nc" id="L577">			} catch (SQLException ex) {</span>
<span class="nc" id="L578">			}</span>

			// Re-throw this exception
<span class="nc" id="L581">			throw sqx;</span>
		} finally {
<span class="fc" id="L583">			conn.setAutoCommit(true);</span>
		}
<span class="fc" id="L585">	}</span>

	/**
	 * Remove a notification from the index.
	 *
	 * All matching notifications should be removed from the index.
	 *
	 * @param notification
	 *            the notification to remove.
	 * @throws Exception
	 *             if an error occurs while removing the notification.
	 * @see gov.usgs.earthquake.distribution.NotificationIndex
	 */
	public synchronized void removeNotification(Notification notification)
			throws Exception {
		// verify connection
<span class="fc" id="L601">		this.verifyConnection();</span>

		// Read the product id from the notification
<span class="fc" id="L604">		ProductId productId = notification.getProductId();</span>
		// Parse the update date from the product id
<span class="fc" id="L606">		java.sql.Date updateDate = new java.sql.Date(productId.getUpdateTime()</span>
<span class="fc" id="L607">				.getTime());</span>
		// Parse the expiration date from the notification
<span class="fc" id="L609">		java.sql.Date expirationDate = new java.sql.Date(notification</span>
<span class="fc" id="L610">				.getExpirationDate().getTime());</span>
		// Read the URL value from the notification
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">		String trackerUrl = notification.getTrackerURL() != null</span>
<span class="fc" id="L613">				? notification.getTrackerURL().toString()</span>
<span class="pc" id="L614">				: &quot;&quot;;</span>

		// Set the values we parsed above
<span class="fc" id="L617">		_dml_removeNotification.setString(1, productId.getSource());</span>
<span class="fc" id="L618">		_dml_removeNotification.setString(2, productId.getType());</span>
<span class="fc" id="L619">		_dml_removeNotification.setString(3, productId.getCode());</span>
<span class="fc" id="L620">		_dml_removeNotification.setDate(4, updateDate);</span>
<span class="fc" id="L621">		_dml_removeNotification.setDate(5, expirationDate);</span>
<span class="fc" id="L622">		_dml_removeNotification.setString(6, trackerUrl);</span>

		// If this is a URL notification, set the product URL value as well
<span class="fc bfc" id="L625" title="All 2 branches covered.">		if (notification instanceof URLNotification) {</span>
<span class="fc" id="L626">			String productUrl = ((URLNotification) notification)</span>
<span class="fc" id="L627">					.getProductURL().toString();</span>
<span class="fc" id="L628">			_dml_removeNotification.setString(7, productUrl);</span>
<span class="fc" id="L629">		} else {</span>
			// _dml_removeNotification.setNull(7, java.sql.Types.VARCHAR);
<span class="fc" id="L631">			_dml_removeNotification.setString(7, &quot;&quot;);</span>
		}

		// already verified above
<span class="fc" id="L635">		Connection conn = getConnection();</span>
		try {
			// Begin a transaction
<span class="fc" id="L638">			conn.setAutoCommit(false);</span>
			// Execute the query
<span class="fc" id="L640">			_dml_removeNotification.executeUpdate();</span>
			// Commit the changes
<span class="fc" id="L642">			conn.setAutoCommit(true);</span>
<span class="nc" id="L643">		} catch (SQLException sqx) {</span>
			// Undo any changes that may be in an unknown state. Ignore
			// exceptions that occur in this call since we're already throwing
			// an exception
			try {
<span class="nc" id="L648">				conn.rollback();</span>
<span class="nc" id="L649">			} catch (SQLException ex) {</span>
<span class="nc" id="L650">			}</span>
			// Re-throw this exception
<span class="nc" id="L652">			throw sqx;</span>
		} finally {
<span class="fc" id="L654">			conn.setAutoCommit(true);</span>
		}
<span class="fc" id="L656">	}</span>

	/**
	 * Search the index for notifications matching id.
	 *
	 * If more than one notification matches, all should be returned.
	 *
	 * @param id
	 *            the ProductId to find.
	 * @return a list of matching notifications.
	 * @throws Exception
	 *             if an error occurs while searching the index.
	 * @see gov.usgs.earthquake.distribution.NotificationIndex
	 */
	public synchronized List&lt;Notification&gt; findNotifications(ProductId id)
			throws Exception {
		// verify connection
<span class="fc" id="L673">		this.verifyConnection();</span>

<span class="fc" id="L675">		String source = id.getSource();</span>
<span class="fc" id="L676">		String type = id.getType();</span>
<span class="fc" id="L677">		String code = id.getCode();</span>
<span class="fc" id="L678">		java.sql.Date update = new java.sql.Date(id.getUpdateTime().getTime());</span>

<span class="fc" id="L680">		_query_findNotificationsById.setString(1, source);</span>
<span class="fc" id="L681">		_query_findNotificationsById.setString(2, type);</span>
<span class="fc" id="L682">		_query_findNotificationsById.setString(3, code);</span>
<span class="fc" id="L683">		_query_findNotificationsById.setDate(4, update);</span>

<span class="fc" id="L685">		return getNotifications(_query_findNotificationsById);</span>
	}

	/**
	 * Search the index for notifications matching the sources, types, and
	 * codes.
	 *
	 * Only one notification for each unique ProductId
	 * (source+type+code+updateTime) should be returned. If sources, types,
	 * and/or codes are null, that parameter should be considered a wildcard. If
	 * sources, types, and codes are all null, a notification for each unique
	 * ProductId in the index should be returned.
	 *
	 * @param source
	 *            sources to include, or all if null.
	 * @param type
	 *            types to include, or all if null.
	 * @param code
	 *            codes to include, or all if null.
	 * @return a list of matching notifications.
	 * @throws Exception
	 *             if an error occurs while searching the index.
	 * @see gov.usgs.earthquake.distribution.NotificationIndex
	 */
	public synchronized List&lt;Notification&gt; findNotifications(String source,
			String type, String code) throws Exception {
		// verify connection
<span class="fc" id="L712">		this.verifyConnection();</span>

<span class="fc bfc" id="L714" title="All 2 branches covered.">		source = (source == null) ? &quot;%&quot; : source.toUpperCase();</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">		type = (type == null) ? &quot;%&quot; : type.toUpperCase();</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">		code = (code == null) ? &quot;%&quot; : code.toUpperCase();</span>

<span class="fc" id="L718">		_query_findNotificationsByData.setString(1, source);</span>
<span class="fc" id="L719">		_query_findNotificationsByData.setString(2, type);</span>
<span class="fc" id="L720">		_query_findNotificationsByData.setString(3, code);</span>

<span class="fc" id="L722">		return getNotifications(_query_findNotificationsByData);</span>
	}

	/**
	 * Search the index for notifications matching the sources, types, and
	 * codes.
	 *
	 * Only one notification for each unique ProductId
	 * (source+type+code+updateTime) should be returned. If sources, types,
	 * and/or codes are null, that parameter should be considered a wildcard. If
	 * sources, types, and codes are all null, a notification for each unique
	 * ProductId in the index should be returned.
	 *
	 * This implementation require synchronization to prevent SQLExceptions
	 * caused by concurrent access. SQLite locks the database whenever there is
	 * an open ResultSet resource. So even read queries can end up causing SQL
	 * concurrent access problems.
	 *
	 * @param sources
	 *            sources to include, or all if null.
	 * @param types
	 *            types to include, or all if null.
	 * @param codes
	 *            codes to include, or all if null.
	 * @return a list of matching notifications.
	 * @throws Exception
	 *             if an error occurs while searching the index.
	 */
	public synchronized List&lt;Notification&gt; findNotifications(
			List&lt;String&gt; sources, List&lt;String&gt; types, List&lt;String&gt; codes)
			throws Exception {
		// verify connection
<span class="fc" id="L754">		this.verifyConnection();</span>

<span class="fc" id="L756">		List&lt;Notification&gt; n = null;</span>

<span class="fc" id="L758">		Connection conn = getConnection();</span>
		try {
			// begin a transaction
<span class="fc" id="L761">			conn.setAutoCommit(false);</span>

			// Create a temporary lookup table
<span class="fc" id="L764">			_dml_createTmpTable.executeUpdate();</span>

			// Populate the temporary lookup table with our given lists
<span class="fc bfc" id="L767" title="All 2 branches covered.">			if (sources != null) {</span>
				// Not null, insert values
<span class="fc" id="L769">				Iterator&lt;String&gt; iter = sources.iterator();</span>
<span class="fc bfc" id="L770" title="All 2 branches covered.">				while (iter.hasNext()) {</span>
<span class="fc" id="L771">					_dml_addTmpSource.setString(1, iter.next());</span>
<span class="fc" id="L772">					_dml_addTmpSource.addBatch();</span>
				}
<span class="fc" id="L774">				_dml_addTmpSource.executeBatch();</span>
			}

<span class="fc bfc" id="L777" title="All 2 branches covered.">			if (types != null) {</span>
				// Not null, insert values
<span class="fc" id="L779">				Iterator&lt;String&gt; iter = types.iterator();</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">				while (iter.hasNext()) {</span>
<span class="fc" id="L781">					_dml_addTmpType.setString(1, iter.next());</span>
<span class="fc" id="L782">					_dml_addTmpType.addBatch();</span>
				}
<span class="fc" id="L784">				_dml_addTmpType.executeBatch();</span>
			}

<span class="fc bfc" id="L787" title="All 2 branches covered.">			if (codes != null) {</span>
				// Not null, insert values
<span class="fc" id="L789">				Iterator&lt;String&gt; iter = codes.iterator();</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">				while (iter.hasNext()) {</span>
<span class="fc" id="L791">					_dml_addTmpCode.setString(1, iter.next());</span>
<span class="fc" id="L792">					_dml_addTmpCode.addBatch();</span>
				}
<span class="fc" id="L794">				_dml_addTmpCode.executeBatch();</span>
			}

			// is this a problem? reading with uncommitted writes?
<span class="fc" id="L798">			PreparedStatement ps = getCorrectStatement(sources, types, codes);</span>
<span class="fc" id="L799">			n = getNotifications(ps);</span>
		} finally {
<span class="fc" id="L801">			conn.rollback();</span>
			// todo: this looks funky, but it's re-enabling autoCommit, which is
			// needed for selects to not block other transactions
<span class="fc" id="L804">			conn.setAutoCommit(true);</span>
		}

<span class="fc" id="L807">		return n;</span>
	}

	/**
	 * Search the index for expired notifications.
	 *
	 * All expired notifications, even if duplicate, should be returned.
	 *
	 * @return a list of expired notifications.
	 * @throws Exception
	 *             if an error occurs while searching the index.
	 * @see gov.usgs.earthquake.distribution.NotificationIndex
	 */
	public synchronized List&lt;Notification&gt; findExpiredNotifications()
			throws Exception {
		// verify connection
<span class="fc" id="L823">		this.verifyConnection();</span>

		// Create a new calendar object set to current date/time
<span class="fc" id="L826">		java.sql.Date curDate = new java.sql.Date((new Date()).getTime());</span>

		// Bind the expiration date parameter and run the query
<span class="fc" id="L829">		_query_findExpiredNotifications.setDate(1, curDate);</span>

<span class="fc" id="L831">		return getNotifications(_query_findExpiredNotifications);</span>
	}

	/**
	 * Executes a prepared statement and parses the result set into a list of
	 * notifications. The prepared statement can have any set of criteria and
	 * all required parameters should be bound before calling this method. The
	 * result set of the prepared statement must include at least: -
	 * PRODUCT_SOURCE_COLUMN&lt;br&gt;
	 * - PRODUCT_TYPE_COLUMN&lt;br&gt;
	 * - PRODUCT_CODE_COLUMN&lt;br&gt;
	 * - PRODUCT_UPDATE_COLUMN&lt;br&gt;
	 * - EXPIRATION_DATE_COLUMN&lt;br&gt;
	 * - TRACKER_URL_COLUMN&lt;br&gt;
	 * - PRODUCT_URL_COLUMN&lt;br&gt;
	 *
	 * @param ps
	 *            The prepared statement to execute.
	 * @return A list of notifications returned by executing the statement.
	 * @throws Exception
	 *             If a &lt;code&gt;SQLException&lt;/code&gt; occurs.
	 */
	protected synchronized List&lt;Notification&gt; getNotifications(PreparedStatement ps)
			throws Exception {
<span class="fc" id="L855">		List&lt;Notification&gt; n = new ArrayList&lt;Notification&gt;();</span>
<span class="fc" id="L856">		ResultSet rs = null;</span>

		try {
<span class="fc" id="L859">			rs = ps.executeQuery();</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L861">				n.add(parseNotification(rs.getString(PRODUCT_SOURCE_COLUMN),</span>
<span class="fc" id="L862">						rs.getString(PRODUCT_TYPE_COLUMN),</span>
<span class="fc" id="L863">						rs.getString(PRODUCT_CODE_COLUMN),</span>
<span class="fc" id="L864">						rs.getDate(PRODUCT_UPDATE_COLUMN),</span>
<span class="fc" id="L865">						rs.getDate(EXPIRATION_DATE_COLUMN),</span>
<span class="fc" id="L866">						rs.getString(TRACKER_URL_COLUMN),</span>
<span class="fc" id="L867">						rs.getString(PRODUCT_URL_COLUMN)));</span>
			}
		} finally {
			try {
<span class="fc" id="L871">				rs.close();</span>
<span class="nc" id="L872">			} catch (Exception e) {</span>
				//ignore
<span class="fc" id="L874">			}</span>
		}

<span class="fc" id="L877">		return n;</span>
	}

	/**
	 * Creates and returns a &lt;code&gt;Notification&lt;/code&gt; based on the provided
	 * data. If the &lt;code&gt;download&lt;/code&gt; string references a valid URL, then a
	 * &lt;code&gt;URLNotification&lt;/code&gt; is created, otherwise a
	 * &lt;code&gt;DefaultNotification&lt;/code&gt; is created.
	 *
	 * @param source
	 *            The product source string.
	 * @param type
	 *            The product type string.
	 * @param code
	 *            The product code string.
	 * @param update
	 *            The latest update date/time for the product.
	 * @param expires
	 *            The date/time when this notification expires.
	 * @param tracker
	 *            A reference to a URL where information about this product is
	 *            posted.
	 * @param download
	 *            A reference to a URL where one can download this product, or
	 *            &lt;code&gt;null&lt;/code&gt; if this is not a
	 *            &lt;code&gt;URLNotification&lt;/code&gt;.
	 *
	 * @return The generated notification, or &lt;code&gt;null&lt;/code&gt; if one could not
	 *         be created (but an exception did not occur).
	 *
	 * @throws Exception
	 *             If the &lt;code&gt;tracker&lt;/code&gt; string cannot be successfully
	 *             parsed into a valid URL.
	 */
	protected Notification parseNotification(String source, String type,
			String code, java.sql.Date update, java.sql.Date expires,
			String tracker, String download) throws Exception {
<span class="fc" id="L914">		Notification n = null;</span>
<span class="fc" id="L915">		ProductId productId = new ProductId(source, type, code, update);</span>
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">		URL trackerURL = !&quot;&quot;.equals(tracker) ? new URL(tracker) : null;</span>
		try {
<span class="fc" id="L918">			n = new URLNotification(productId, expires, trackerURL, new URL(download));</span>
<span class="fc" id="L919">		} catch (MalformedURLException mux) {</span>
<span class="fc" id="L920">			n = new DefaultNotification(productId, expires, trackerURL);</span>
<span class="fc" id="L921">		}</span>
<span class="fc" id="L922">		return n;</span>
	}

	/**
	 * @param sources List string of sources
	 * @param types List string of types
	 * @param codes List string of codes
	 * @return prepared query based on what is/is not null
	 * @throws Exception if error occurs
	 */
	protected PreparedStatement getCorrectStatement(List&lt;String&gt; sources,
			List&lt;String&gt; types, List&lt;String&gt; codes) throws Exception {
<span class="fc bfc" id="L934" title="All 6 branches covered.">		if (sources != null &amp;&amp; types != null &amp;&amp; codes != null) {</span>
<span class="fc" id="L935">			return _query_searchBySourceTypeCode;</span>
<span class="pc bpc" id="L936" title="1 of 6 branches missed.">		} else if (sources != null &amp;&amp; types != null &amp;&amp; codes == null) {</span>
<span class="fc" id="L937">			return _query_searchBySourceType;</span>
<span class="pc bpc" id="L938" title="2 of 6 branches missed.">		} else if (sources != null &amp;&amp; types == null &amp;&amp; codes != null) {</span>
<span class="nc" id="L939">			return _query_searchBySourceCode;</span>
<span class="fc bfc" id="L940" title="All 6 branches covered.">		} else if (sources == null &amp;&amp; types != null &amp;&amp; codes != null) {</span>
<span class="fc" id="L941">			return _query_searchByTypeCode;</span>
<span class="pc bpc" id="L942" title="2 of 6 branches missed.">		} else if (sources != null &amp;&amp; types == null &amp;&amp; codes == null) {</span>
<span class="fc" id="L943">			return _query_searchBySource;</span>
<span class="pc bpc" id="L944" title="2 of 6 branches missed.">		} else if (sources == null &amp;&amp; types != null &amp;&amp; codes == null) {</span>
<span class="fc" id="L945">			return _query_searchByType;</span>
<span class="pc bpc" id="L946" title="2 of 6 branches missed.">		} else if (sources == null &amp;&amp; types == null &amp;&amp; codes != null) {</span>
<span class="fc" id="L947">			return _query_searchByCode;</span>
<span class="pc bpc" id="L948" title="3 of 6 branches missed.">		} else if (sources == null &amp;&amp; types == null &amp;&amp; codes == null) {</span>
<span class="fc" id="L949">			return _query_getAllNotifications;</span>
		}

<span class="nc" id="L952">		return null;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>