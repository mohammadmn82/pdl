<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Product.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.earthquake.product</a> &gt; <span class="el_source">Product.java</span></div><h1>Product.java</h1><pre class="source lang-java linenums">/*
 * Product
 */
package gov.usgs.earthquake.product;

import gov.usgs.util.CryptoUtils;
import gov.usgs.util.XmlUtils;
import gov.usgs.util.CryptoUtils.Version;

import java.security.PublicKey;
import java.security.PrivateKey;

import java.math.BigDecimal;
import java.net.URI;
import java.net.URL;

import java.util.Date;
import java.util.List;
import java.util.LinkedList;
import java.util.Map;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * One or more pieces of Content with metadata.
 *
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;strong&gt;ID&lt;/strong&gt;&lt;/dt&gt;
 * &lt;dd&gt;
 * Products each have a unique {@link ProductId}.
 * &lt;/dd&gt;
 *
 * &lt;dt&gt;&lt;strong&gt;Versioning&lt;/strong&gt;&lt;/dt&gt;
 * &lt;dd&gt;
 * It is possible to create multiple versions of the same product,
 * by reusing the same &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and
 * &lt;code&gt;code&lt;/code&gt;, with a different &lt;code&gt;updateTime&lt;/code&gt;.
 * &lt;br&gt;
 * More recent (newer) &lt;code&gt;updateTime&lt;/code&gt;s &lt;strong&gt;supersede&lt;/strong&gt;
 * Less recent (older) &lt;code&gt;updateTime&lt;/code&gt;s.
 * &lt;/dd&gt;
 *
 * &lt;dt&gt;&lt;strong&gt;Status&lt;/strong&gt;&lt;/dt&gt;
 * &lt;dd&gt;
 * To &lt;strong&gt;delete&lt;/strong&gt; a product, create a new version (updateTime)
 * and set it's status to {@link STATUS_DELETE}.  All other statuses
 * ({@link STATUS_UPDATE} by default) are considered updates, and any
 * value can be used in product-specific ways.
 * &lt;/dd&gt;
 *
 * &lt;dt&gt;&lt;strong&gt;Properties&lt;/strong&gt;&lt;/dt&gt;
 * &lt;dd&gt;
 * Products have key/value attributes that are Strings.
 * These can be useful to convey summary information about a product,
 * so consumers can quickly decide whether to process before opening
 * any product contents.
 * &lt;/dd&gt;
 *
 * &lt;dt&gt;&lt;strong&gt;Links&lt;/strong&gt;&lt;/dt&gt;
 * &lt;dd&gt;
 * Similar to properties, links allow a Product to specify a
 * &lt;code&gt;relation&lt;/code&gt; and one or more &lt;code&gt;link&lt;/code&gt; for each
 * relation type.
 * Links must be {@link java.net.URI}s, and may be {@link ProductId}s.
 * &lt;/dd&gt;
 *
 * &lt;dt&gt;&lt;strong&gt;Contents&lt;/strong&gt;&lt;/dt&gt;
 * &lt;dd&gt;
 * Many Products start as a directory of files, and metadata is determined later.
 * It's also possible to create products without any Contents attached,
 * if all the necessary information can be encoded using Properties or Links.
 * &lt;br&gt;
 * One special &quot;empty path&quot; content, literally at the empty-string path,
 * is handled differently; since an empty path cannot be written to a file.
 * PDL typically reads this in from standard input, or delivers this on
 * standard input to external processes.
 * &lt;/dd&gt;
 *
 * &lt;dt&gt;&lt;strong&gt;Signature&lt;/strong&gt;&lt;/dt&gt;
 * &lt;dd&gt;
 * A product can have a digital signature, based on a digest of all
 * product contents and metadata.  These are required for most purposes.
 * {@link CryptoUtils} provides utilities for working with OpenSSH keypairs.
 * &lt;/dd&gt;
 *
 * &lt;dt&gt;&lt;strong&gt;Tracker URL (Deprecated)&lt;/strong&gt;&lt;/dt&gt;
 * &lt;dd&gt;
 * Tracker URLs were initially used to track processing status as
 * distribution progressed.  These are no longer supported, and often
 * introduced new problems.
 * &lt;/dd&gt;
 * &lt;/dl&gt;
 */
public class Product {

<span class="fc" id="L97">	private static final Logger LOGGER = Logger.getLogger(Product.class</span>
<span class="fc" id="L98">			.getName());</span>

	/** The status message when a product is being updated. */
	public static final String STATUS_UPDATE = &quot;UPDATE&quot;;

	/** The status message when a product is being deleted. */
	public static final String STATUS_DELETE = &quot;DELETE&quot;;

	/** Property for eventsource */
	public static final String EVENTSOURCE_PROPERTY = &quot;eventsource&quot;;
	/** Property for eventsourcecode */
	public static final String EVENTSOURCECODE_PROPERTY = &quot;eventsourcecode&quot;;
	/** Property for eventtime */
	public static final String EVENTTIME_PROPERTY = &quot;eventtime&quot;;
	/** Property for magnitude */
	public static final String MAGNITUDE_PROPERTY = &quot;magnitude&quot;;
	/** Property for latitude */
	public static final String LATITUDE_PROPERTY = &quot;latitude&quot;;
	/** Property for longitude */
	public static final String LONGITUDE_PROPERTY = &quot;longitude&quot;;
	/** Property for depth */
	public static final String DEPTH_PROPERTY = &quot;depth&quot;;
	/** Property for version */
	public static final String VERSION_PROPERTY = &quot;version&quot;;

	/** A unique identifier for this product. */
	private ProductId id;

	/** A terse status message. */
	private String status;

	/** Properties of this product. */
<span class="fc" id="L130">	private Map&lt;String, String&gt; properties = new HashMap&lt;String, String&gt;();</span>

	/** Links to other products and related resources. */
<span class="fc" id="L133">	private Map&lt;String, List&lt;URI&gt;&gt; links = new HashMap&lt;String, List&lt;URI&gt;&gt;();</span>

	/** Product contents. Mapping from path to content. */
<span class="fc" id="L136">	private Map&lt;String, Content&gt; contents = new HashMap&lt;String, Content&gt;();</span>

	/** A URL where status updates are sent. */
<span class="fc" id="L139">	private URL trackerURL = null;</span>

	/** A signature generated by the product creator. */
<span class="fc" id="L142">	private String signature = null;</span>

	/** Signature version. */
<span class="fc" id="L145">	private Version signatureVersion = Version.SIGNATURE_V1;</span>

	/**
	 * Construct a new Product with status &quot;UPDATE&quot;.
	 *
	 * @param id
	 *            the product's unique Id.
	 */
	public Product(final ProductId id) {
<span class="fc" id="L154">		this(id, STATUS_UPDATE);</span>
<span class="fc" id="L155">	}</span>

	/**
	 * Construct a new Product.
	 *
	 * @param id
	 *            the product's unique Id.
	 * @param status
	 *            the product's status.
	 */
<span class="fc" id="L165">	public Product(final ProductId id, final String status) {</span>
<span class="fc" id="L166">		setId(id);</span>
<span class="fc" id="L167">		setStatus(status);</span>
<span class="fc" id="L168">	}</span>

	/**
	 * Copy constructor.
	 *
	 * @param that
	 *            the product to copy.
	 */
	public Product(final Product that) {
<span class="fc" id="L177">		this(new ProductId(that.getId().getSource(), that.getId().getType(),</span>
<span class="fc" id="L178">				that.getId().getCode(), that.getId().getUpdateTime()), that</span>
<span class="fc" id="L179">				.getStatus());</span>
<span class="fc" id="L180">		this.setTrackerURL(that.getTrackerURL());</span>
<span class="fc" id="L181">		this.setProperties(that.getProperties());</span>
<span class="fc" id="L182">		this.setLinks(that.getLinks());</span>
<span class="fc" id="L183">		this.setContents(that.getContents());</span>
<span class="fc" id="L184">		this.setSignature(that.getSignature());</span>
<span class="fc" id="L185">	}</span>

	/**
	 * @return the id
	 */
	public ProductId getId() {
<span class="fc" id="L191">		return id;</span>
	}

	/**
	 * @param id
	 *            the id to set
	 */
	public void setId(final ProductId id) {
<span class="fc" id="L199">		this.id = id;</span>
<span class="fc" id="L200">	}</span>

	/**
	 * @return the status
	 */
	public String getStatus() {
<span class="fc" id="L206">		return status;</span>
	}

	/**
	 * @param status
	 *            the status to set
	 */
	public void setStatus(final String status) {
<span class="fc" id="L214">		this.status = status;</span>
<span class="fc" id="L215">	}</span>

	/**
	 * Product.STATUS_DELETE.equalsIgnoreCase(status).
	 *
	 * @return whether this product is deleted
	 */
	public boolean isDeleted() {
<span class="nc bnc" id="L223" title="All 2 branches missed.">		if (STATUS_DELETE.equalsIgnoreCase(this.status)) {</span>
<span class="nc" id="L224">			return true;</span>
		} else {
<span class="nc" id="L226">			return false;</span>
		}
	}

	/**
	 * @return the properties
	 */
	public Map&lt;String, String&gt; getProperties() {
<span class="fc" id="L234">		return properties;</span>
	}

	/**
	 * @param properties
	 *            the properties to set
	 */
	public void setProperties(final Map&lt;String, String&gt; properties) {
<span class="fc" id="L242">		this.properties.putAll(properties);</span>
<span class="fc" id="L243">	}</span>

	/**
	 * Returns a reference to the links map.
	 *
	 * @return the links
	 */
	public Map&lt;String, List&lt;URI&gt;&gt; getLinks() {
<span class="fc" id="L251">		return links;</span>
	}

	/**
	 * Copies entries from provided map.
	 *
	 * @param links
	 *            the links to set
	 */
	public void setLinks(final Map&lt;String, List&lt;URI&gt;&gt; links) {
<span class="fc" id="L261">		this.links.putAll(links);</span>
<span class="fc" id="L262">	}</span>

	/**
	 * Add a link to a product.
	 *
	 * @param relation
	 *            how link is related to product.
	 * @param href
	 *            actual link.
	 */
	public void addLink(final String relation, final URI href) {
<span class="fc" id="L273">		List&lt;URI&gt; relationLinks = links.get(relation);</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">		if (relationLinks == null) {</span>
<span class="fc" id="L275">			relationLinks = new LinkedList&lt;URI&gt;();</span>
<span class="fc" id="L276">			links.put(relation, relationLinks);</span>
		}
<span class="fc" id="L278">		relationLinks.add(href);</span>
<span class="fc" id="L279">	}</span>

	/**
	 * Returns a reference to the contents map.
	 *
	 * @return the contents
	 */
	public Map&lt;String, Content&gt; getContents() {
<span class="fc" id="L287">		return contents;</span>
	}

	/**
	 * Copies entries from provided map.
	 *
	 * @param contents
	 *            the contents to set
	 */
	public void setContents(final Map&lt;String, Content&gt; contents) {
<span class="fc" id="L297">		this.contents.clear();</span>
<span class="fc" id="L298">		this.contents.putAll(contents);</span>
<span class="fc" id="L299">	}</span>

	/**
	 * @return the trackerURL
	 */
	public URL getTrackerURL() {
<span class="fc" id="L305">		return trackerURL;</span>
	}

	/**
	 * @param trackerURL
	 *            the trackerURL to set
	 */
	public void setTrackerURL(final URL trackerURL) {
<span class="fc" id="L313">		this.trackerURL = trackerURL;</span>
<span class="fc" id="L314">	}</span>

	/**
	 * @return the signature
	 */
	public String getSignature() {
<span class="fc" id="L320">		return signature;</span>
	}

	/**
	 * @return the signature
	 */
	public Version getSignatureVersion() {
<span class="fc" id="L327">		return signatureVersion;</span>
	}

	/**
	 * @param signature
	 *            the signature to set
	 */
	public void setSignature(final String signature) {
<span class="fc" id="L335">		this.signature = signature;</span>
<span class="fc" id="L336">	}</span>

	/**
	 * @param version
	 *            the signature version to set
	 */
	public void setSignatureVersion(final Version version) {
<span class="fc" id="L343">		this.signatureVersion = version;</span>
<span class="fc" id="L344">	}</span>

	/**
	 * Sign this product using a PrivateKey and signature v1.
	 * @param privateKey used to sign
	 * @throws Exception if error occurs
	 */
	public void sign(final PrivateKey privateKey) throws Exception {
<span class="fc" id="L352">		this.sign(privateKey, Version.SIGNATURE_V1);</span>
<span class="fc" id="L353">	}</span>

	/**
	 * Sign this product using a PrivateKey.
	 *
	 * @param privateKey
	 *            a DSAPrivateKey or RSAPrivateKey.
	 * @param version
	 *            the signature version to use.
	 * @throws Exception if error occurs
	 */
	public void sign(final PrivateKey privateKey, final Version version) throws Exception {
<span class="fc" id="L365">		setSignature(CryptoUtils.sign(</span>
				privateKey,
<span class="fc" id="L367">				ProductDigest.digestProduct(this, version),</span>
				version));
<span class="fc" id="L369">		setSignatureVersion(version);</span>
<span class="fc" id="L370">	}</span>

	/**
	 * Verify this product's signature using Signature V1.
	 * @param publicKeys Array of public keys to verify
	 * @throws Exception if error occurs
	 * @return true if valid, false otherwise.
	 */
	public boolean verifySignature(final PublicKey[] publicKeys)
			throws Exception {
<span class="fc" id="L380">		return verifySignature(publicKeys, getSignatureVersion());</span>
	}

	/**
	 * Verify this product's signature.
	 *
	 * When a product has no signature, this method returns false. The array of
	 * public keys corresponds to one or more keys that may have generated the
	 * signature. If any of the keys verify, this method returns true.
	 *
	 * @param publicKeys
	 *            an array of publicKeys to test.
	 * @param version
	 *            the signature version to use.
	 * @return true if valid, false otherwise.
	 * @throws Exception if error occurs
	 */
	public boolean verifySignature(final PublicKey[] publicKeys, final Version version)
			throws Exception {
<span class="fc bfc" id="L399" title="All 2 branches covered.">		return verifySignatureKey(publicKeys, version) != null;</span>
	}

	/**
	 * Try to verify using multiple candidate keys.
	 * @param publicKeys an array of publicKeys to test
	 * @param version the signature version to use.
	 * @return true if valid, false otherwise.
	 * @throws Exception if error occurs
	 */
	public PublicKey verifySignatureKey(final PublicKey[] publicKeys, final Version version) throws Exception {
<span class="fc bfc" id="L410" title="All 2 branches covered.">		if (signature == null) {</span>
<span class="fc" id="L411">			return null;</span>
		}

<span class="fc" id="L414">		byte[] digest = ProductDigest.digestProduct(this, version);</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">		for (PublicKey key : publicKeys) {</span>
			try {
<span class="fc bfc" id="L417" title="All 2 branches covered.">				if (CryptoUtils.verify(key, digest, getSignature(), version)) {</span>
<span class="fc" id="L418">					return key;</span>
				}
<span class="nc" id="L420">			} catch (Exception e) {</span>
<span class="nc" id="L421">				LOGGER.log(Level.FINEST, &quot;Exception while verifying signature&quot;,</span>
								e);
<span class="fc" id="L423">			}</span>
		}
<span class="fc" id="L425">		return null;</span>
	}

	/**
	 * Get the event id.
	 *
	 * The event id is the combination of event source and event source code.
	 *
	 * @return the event id, or null if either event source or event source code
	 *         is null.
	 */
	public String getEventId() {
<span class="fc" id="L437">		String eventSource = getEventSource();</span>
<span class="fc" id="L438">		String eventSourceCode = getEventSourceCode();</span>
<span class="pc bpc" id="L439" title="1 of 4 branches missed.">		if (eventSource == null &amp;&amp; eventSourceCode == null) {</span>
<span class="fc" id="L440">			return null;</span>
		}
<span class="fc" id="L442">		return (eventSource + eventSourceCode).toLowerCase();</span>
	}

	/**
	 * Set both the network and networkId at the same time.
	 *
	 * @param source
	 *            the originating network.
	 * @param sourceCode
	 *            the originating network's id.
	 */
	public void setEventId(final String source, final String sourceCode) {
<span class="fc" id="L454">		setEventSource(source);</span>
<span class="fc" id="L455">		setEventSourceCode(sourceCode);</span>
<span class="fc" id="L456">	}</span>

	/**
	 * Get the event source property.
	 *
	 * @return the event source property, or null if no event source property
	 *         set.
	 */
	public String getEventSource() {
<span class="fc" id="L465">		return this.properties.get(EVENTSOURCE_PROPERTY);</span>
	}

	/**
	 * Set the event source property.
	 *
	 * @param eventSource
	 *            the event source to set.
	 */
	public void setEventSource(final String eventSource) {
<span class="fc bfc" id="L475" title="All 2 branches covered.">		if (eventSource == null) {</span>
<span class="fc" id="L476">			this.properties.remove(EVENTSOURCE_PROPERTY);</span>
		} else {
<span class="fc" id="L478">			this.properties</span>
<span class="fc" id="L479">					.put(EVENTSOURCE_PROPERTY, eventSource.toLowerCase());</span>
		}
<span class="fc" id="L481">	}</span>

	/**
	 * Get the event source code property.
	 *
	 * @return the event source code property, or null if no event source code
	 *         property set.
	 */
	public String getEventSourceCode() {
<span class="fc" id="L490">		return this.properties.get(EVENTSOURCECODE_PROPERTY);</span>
	}

	/**
	 * Set the event id property.
	 *
	 * @param eventSourceCode
	 *            the event id to set.
	 */
	public void setEventSourceCode(final String eventSourceCode) {
<span class="fc bfc" id="L500" title="All 2 branches covered.">		if (eventSourceCode == null) {</span>
<span class="fc" id="L501">			this.properties.remove(EVENTSOURCECODE_PROPERTY);</span>
		} else {
<span class="fc" id="L503">			this.properties.put(EVENTSOURCECODE_PROPERTY,</span>
<span class="fc" id="L504">					eventSourceCode.toLowerCase());</span>
		}
<span class="fc" id="L506">	}</span>

	/**
	 * Get the event time property as a date.
	 *
	 * @return the event time property as a date, or null if no date property
	 *         set.
	 */
	public Date getEventTime() {
<span class="fc" id="L515">		String strDate = this.properties.get(EVENTTIME_PROPERTY);</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">		if (strDate == null) {</span>
<span class="fc" id="L517">			return null;</span>
		}
<span class="fc" id="L519">		return XmlUtils.getDate(strDate);</span>
	}

	/**
	 * Set the event time property as a date.
	 *
	 * @param eventTime
	 *            the event time to set.
	 */
	public void setEventTime(final Date eventTime) {
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">		if (eventTime == null) {</span>
<span class="nc" id="L530">			this.properties.remove(EVENTTIME_PROPERTY);</span>
		} else {
<span class="fc" id="L532">			this.properties.put(EVENTTIME_PROPERTY,</span>
<span class="fc" id="L533">					XmlUtils.formatDate(eventTime));</span>
		}
<span class="fc" id="L535">	}</span>

	/**
	 * Get the magnitude property as a big decimal.
	 *
	 * @return the magnitude property as a big decimal, or null if no magnitude
	 *         property set.
	 */
	public BigDecimal getMagnitude() {
<span class="fc" id="L544">		String strMag = this.properties.get(MAGNITUDE_PROPERTY);</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">		if (strMag == null) {</span>
<span class="fc" id="L546">			return null;</span>
		}
<span class="fc" id="L548">		return new BigDecimal(strMag);</span>
	}

	/**
	 * Set the magnitude property as a big decimal.
	 *
	 * @param magnitude
	 *            the magnitude to set.
	 */
	public void setMagnitude(final BigDecimal magnitude) {
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">		if (magnitude == null) {</span>
<span class="nc" id="L559">			this.properties.remove(MAGNITUDE_PROPERTY);</span>
		} else {
<span class="fc" id="L561">			this.properties.put(MAGNITUDE_PROPERTY, magnitude.toPlainString());</span>
		}
<span class="fc" id="L563">	}</span>

	/**
	 * Get the latitude property as a big decimal.
	 *
	 * @return latitude property as a big decimal, or null if no latitude
	 *         property set.
	 */
	public BigDecimal getLatitude() {
<span class="fc" id="L572">		String strLat = this.properties.get(LATITUDE_PROPERTY);</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">		if (strLat == null) {</span>
<span class="fc" id="L574">			return null;</span>
		}
<span class="fc" id="L576">		return new BigDecimal(strLat);</span>
	}

	/**
	 * Set the latitude property as a big decimal.
	 *
	 * @param latitude
	 *            the latitude to set.
	 */
	public void setLatitude(final BigDecimal latitude) {
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">		if (latitude == null) {</span>
<span class="nc" id="L587">			this.properties.remove(LATITUDE_PROPERTY);</span>
		} else {
<span class="fc" id="L589">			this.properties.put(LATITUDE_PROPERTY, latitude.toPlainString());</span>
		}
<span class="fc" id="L591">	}</span>

	/**
	 * Get the longitude property as a big decimal.
	 *
	 * @return longitude property as a big decimal, or null if no longitude
	 *         property set.
	 */
	public BigDecimal getLongitude() {
<span class="fc" id="L600">		String strLon = this.properties.get(LONGITUDE_PROPERTY);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">		if (strLon == null) {</span>
<span class="fc" id="L602">			return null;</span>
		}
<span class="fc" id="L604">		return new BigDecimal(strLon);</span>
	}

	/**
	 * Set the longitude property as a big decimal.
	 *
	 * @param longitude
	 *            the longitude to set.
	 */
	public void setLongitude(final BigDecimal longitude) {
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">		if (longitude == null) {</span>
<span class="nc" id="L615">			this.properties.remove(LONGITUDE_PROPERTY);</span>
		} else {
<span class="fc" id="L617">			this.properties.put(LONGITUDE_PROPERTY, longitude.toPlainString());</span>
		}
<span class="fc" id="L619">	}</span>

	/**
	 * Get the depth property as a big decimal.
	 *
	 * @return depth property as big decimal, or null if no depth property set.
	 */
	public BigDecimal getDepth() {
<span class="fc" id="L627">		String strDepth = this.properties.get(DEPTH_PROPERTY);</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">		if (strDepth == null) {</span>
<span class="fc" id="L629">			return null;</span>
		}
<span class="fc" id="L631">		return new BigDecimal(strDepth);</span>
	}

	/**
	 * Set the depth property as a big decimal.
	 *
	 * @param depth
	 *            the depth to set.
	 */
	public void setDepth(final BigDecimal depth) {
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">		if (depth == null) {</span>
<span class="nc" id="L642">			this.properties.remove(DEPTH_PROPERTY);</span>
		} else {
<span class="fc" id="L644">			this.properties.put(DEPTH_PROPERTY, depth.toPlainString());</span>
		}
<span class="fc" id="L646">	}</span>

	/**
	 * Get the version property.
	 *
	 * @return the version property, or null if no version property set.
	 */
	public String getVersion() {
<span class="fc" id="L654">		return this.properties.get(VERSION_PROPERTY);</span>
	}

	/**
	 * Set the version property.
	 *
	 * @param version
	 *            the version to set.
	 */
	public void setVersion(final String version) {
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">		if (version == null) {</span>
<span class="nc" id="L665">			this.properties.remove(VERSION_PROPERTY);</span>
		} else {
<span class="fc" id="L667">			this.properties.put(VERSION_PROPERTY, version);</span>
		}
<span class="fc" id="L669">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>