<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CryptoUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.util</a> &gt; <span class="el_source">CryptoUtils.java</span></div><h1>CryptoUtils.java</h1><pre class="source lang-java linenums">/*
 * CryptoUtils
 *
 * $Id$
 * $URL$
 */
package gov.usgs.util;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.security.Key;
import java.security.PublicKey;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.interfaces.DSAPrivateKey;
import java.security.interfaces.DSAPublicKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.DSAPublicKeySpec;
import java.security.spec.DSAPrivateKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.MGF1ParameterSpec;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.PSSParameterSpec;
import java.security.spec.RSAPublicKeySpec;
import java.security.spec.RSAPrivateKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.Signature;
import java.security.SignatureException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.LinkedList;
import java.util.List;

import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;

import ch.ethz.ssh2.crypto.PEMDecoder;

/**
 * Encryption and signing utilities.
 */
<span class="nc" id="L57">public class CryptoUtils {</span>

	/** Algorithm used by AES keys and ciphers. */
	public static final String AES_ALGORITHM = &quot;AES&quot;;
	/** Number of bits for AES 128 bit key. */
	public static final int AES_128 = 128;
	/** Number of bits for AES 256 bit key. */
	public static final int AES_256 = 256;

	/** Algorithm used by DSA keys. */
	public static final String DSA_ALGORITHM = &quot;DSA&quot;;
	/** Algorithm used for signature with DSA key. */
	public static final String DSA_SIGNATURE_ALGORITHM = &quot;SHA1withDSA&quot;;
	/** Number of bits for DSA 1024 bit key. */
	public static final int DSA_1024 = 1024;

	/** Algorithm used by RSA keys and ciphers. */
	public static final String RSA_ALGORITHM = &quot;RSA&quot;;
	/** Algorithm used for signature with RSA key. */
	public static final String RSA_SIGNATURE_ALGORITHM = &quot;SHA1withRSA&quot;;
	/** Number of bits for RSA 2048 bit key. */
	public static final int RSA_2048 = 2048;
	/** Number of bits for RSA 4096 bit key. */
	public static final int RSA_4096 = 4096;

	/** Signature versions. */
<span class="fc" id="L83">	public enum Version {</span>
		/** Signature enum for v1 */
<span class="fc" id="L85">		SIGNATURE_V1(&quot;v1&quot;),</span>
		/** Signature enum for v2 */
<span class="fc" id="L87">		SIGNATURE_V2(&quot;v2&quot;);</span>

		private String value;

<span class="fc" id="L91">		Version(final String value) {</span>
<span class="fc" id="L92">			this.value = value;</span>
<span class="fc" id="L93">		}</span>

		public String toString() {
<span class="fc" id="L96">			return this.value;</span>
		}

		/**
		 * @param value to get a signature from
		 * @return a version
		 * @throws IllegalArgumentException if unknown version.
		 */
		public static Version fromString(final String value) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">			if (SIGNATURE_V1.value.equals(value)) {</span>
<span class="fc" id="L106">				return SIGNATURE_V1;</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">			} else if (SIGNATURE_V2.value.equals(value)) {</span>
<span class="fc" id="L108">				return SIGNATURE_V2;</span>
			} else {
<span class="nc" id="L110">				throw new IllegalArgumentException(&quot;Invalid signature version&quot;);</span>
			}
		}
	}

	/** v2 Algorithm for DSA signature */
	public static final String SIGNATURE_V2_DSA_ALGORITHM = &quot;SHA256withDSA&quot;;
	/** v2 Algorithm for RSA signature */
	public static final String SIGNATURE_V2_RSA_ALGORITHM = &quot;RSASSA-PSS&quot;;

	/**
	 * Process a data stream using a cipher.
	 *
	 * If cipher is initialized to ENCRYPT_MODE, the input stream will be
	 * encrypted. If cipher is initialized to DECRYPT_MODE, the input stream
	 * will be decrypted.
	 *
	 * @param cipher
	 *            an initialized cipher.
	 * @param in
	 *            the data to encrypt.
	 * @param out
	 *            where encrypted data is written.
	 * @throws NoSuchAlgorithmException if invalid encrypt/decrypt algorithm
	 * @throws NoSuchPaddingException on padding error
	 * @throws InvalidKeyException if key is not RSA or DSA.
	 * @throws IOException if IO error occurs
	 */
	public static void processCipherStream(final Cipher cipher,
			final InputStream in, final OutputStream out)
			throws NoSuchAlgorithmException, NoSuchPaddingException,
			InvalidKeyException, IOException {
<span class="fc" id="L142">		CipherOutputStream cos = new CipherOutputStream(out, cipher);</span>
<span class="fc" id="L143">		StreamUtils.transferStream(in, cos);</span>
<span class="fc" id="L144">	}</span>

	/**
	 * Create and initialize an encrypting cipher using key.getAlgorithm() as
	 * transformation.
	 *
	 * @param key
	 *            the key used to encrypt.
	 * @return a cipher used to encrypt.
	 * @throws NoSuchAlgorithmException on invalid algorithm
	 * @throws NoSuchPaddingException on invalid padding
	 * @throws InvalidKeyException if key is not RSA or DSA.
	 */
	public static Cipher getEncryptCipher(final Key key)
			throws NoSuchAlgorithmException, NoSuchPaddingException,
			InvalidKeyException {
<span class="fc" id="L160">		Cipher cipher = Cipher.getInstance(key.getAlgorithm());</span>
<span class="fc" id="L161">		cipher.init(Cipher.ENCRYPT_MODE, key);</span>
<span class="fc" id="L162">		return cipher;</span>
	}

	/**
	 * Create and initialize a decrypting cipher using key.getAlgorithm as
	 * transformation.
	 *
	 * @param key
	 *            the key used to decrypt.
	 * @return a cipher used to decrypt.
	 * @throws NoSuchAlgorithmException on invalid algorithm
	 * @throws NoSuchPaddingException on invalid padding
	 * @throws InvalidKeyException if key is not RSA or DSA.
	 */
	public static Cipher getDecryptCipher(final Key key)
			throws NoSuchAlgorithmException, NoSuchPaddingException,
			InvalidKeyException {
<span class="fc" id="L179">		Cipher cipher = Cipher.getInstance(key.getAlgorithm());</span>
<span class="fc" id="L180">		cipher.init(Cipher.DECRYPT_MODE, key);</span>
<span class="fc" id="L181">		return cipher;</span>
	}

	/**
	 * Create and configure a signature object based on key type.
	 *
	 * @param key
	 *     Key used to sign/verify.
	 * @param version
	 *     SIGNATURE_V1 or SIGNATURE_V2
	 * @return
	 *     Configured Signature object
	 * @throws InvalidKeyException
	 *     if key is not RSA or DSA.
	 * @throws NoSuchAlgorithmException
	 *     on invalid algorithm
	 * @throws SignatureException
	 *     on signature error
	 */
	public static Signature getSignature(final Key key, final Version version)
			throws InvalidKeyException, NoSuchAlgorithmException,
					SignatureException {
<span class="fc" id="L203">		Signature signature = null;</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">		if (version == Version.SIGNATURE_V1) {</span>
<span class="fc bfc" id="L205" title="All 4 branches covered.">			if (key instanceof DSAPrivateKey || key instanceof DSAPublicKey) {</span>
<span class="fc" id="L206">				signature = Signature.getInstance(DSA_SIGNATURE_ALGORITHM);</span>
<span class="pc bpc" id="L207" title="1 of 4 branches missed.">			} else if (key instanceof RSAPrivateKey || key instanceof RSAPublicKey) {</span>
<span class="fc" id="L208">				signature = Signature.getInstance(RSA_SIGNATURE_ALGORITHM);</span>
			}
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">		} else if (version == Version.SIGNATURE_V2) {</span>
<span class="fc bfc" id="L211" title="All 4 branches covered.">			if (key instanceof DSAPrivateKey || key instanceof DSAPublicKey) {</span>
<span class="fc" id="L212">				signature = Signature.getInstance(SIGNATURE_V2_DSA_ALGORITHM);</span>
<span class="pc bpc" id="L213" title="1 of 4 branches missed.">			} else if (key instanceof RSAPrivateKey || key instanceof RSAPublicKey) {</span>
<span class="fc" id="L214">				signature = Signature.getInstance(SIGNATURE_V2_RSA_ALGORITHM);</span>
			}
		} else {
<span class="nc" id="L217">			throw new IllegalArgumentException(&quot;Unexpected signature version &quot; + version);</span>
		}
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">		if (signature == null) {</span>
<span class="nc" id="L220">			throw new InvalidKeyException(&quot;Expected DSA or RSA key&quot;);</span>
		}
<span class="fc" id="L222">		return signature;</span>
	}

	/**
	 *
	 * @param key Key used to sign/verify.
	 * @param version SIGNATURE_V1 or SIGNATURE_V2
	 * @param signature A signature
	 * @throws InvalidAlgorithmParameterException
	 *     on invalid or inappropriate algorithm parameters
	 */
	public static void configureSignature(final Key key, final Version version,
			final Signature signature) throws InvalidAlgorithmParameterException {
<span class="fc bfc" id="L235" title="All 6 branches covered.">		if (version == Version.SIGNATURE_V2</span>
				&amp;&amp; (key instanceof RSAPrivateKey || key instanceof RSAPublicKey)) {
			int keySize;
<span class="fc bfc" id="L238" title="All 2 branches covered.">			if (key instanceof RSAPrivateKey) {</span>
<span class="fc" id="L239">				keySize = ((RSAPrivateKey)key).getModulus().bitLength();</span>
			} else {
<span class="fc" id="L241">				keySize = ((RSAPublicKey)key).getModulus().bitLength();</span>
			}
			// match python cryptography calculation:
			// https://github.com/pyca/cryptography/blob/b16561670320c65a18cce41d0db0c42ab68350a9/src/cryptography/hazmat/primitives/asymmetric/padding.py#L73
			// 32 = (sha)256 / 8
<span class="fc" id="L246">			int maxSaltLength = ((keySize + 6) / 8) - 32 - 2;</span>
<span class="fc" id="L247">			signature.setParameter(</span>
					new PSSParameterSpec(&quot;SHA-256&quot;, &quot;MGF1&quot;,
							MGF1ParameterSpec.SHA256, maxSaltLength, 1));
		}
<span class="fc" id="L251">	}</span>

	/**
	 * A convenience method that chooses a signature algorithm based on the key
	 * type. Works with DSA and RSA keys.
	 *
	 * @param privateKey a private key
	 * @param data data to sign
	 * @return signature as hex encoded string
	 * @throws InvalidAlgorithmParameterException
	 *     on invalid or inappropriate algorithm parameters
	 * @throws InvalidKeyException
	 *     if key is not RSA or DSA.
	 * @throws NoSuchAlgorithmException
	 *     on invalid algorithm
	 * @throws SignatureException
	 *     on signature error
	 */
	public static String sign(final PrivateKey privateKey, final byte[] data)
			throws InvalidAlgorithmParameterException, InvalidKeyException,
			NoSuchAlgorithmException, SignatureException {
		// use v1 by default
<span class="nc" id="L273">		return sign(privateKey, data, Version.SIGNATURE_V1);</span>
	}

	/**
	 * Generate a signature.
	 *
	 * @param privateKey
	 *            private key to use, should be acceptable by signature
	 *            instance.
	 * @param data
	 *            data/hash to sign.
	 * @param version
	 *            the signature version.
	 * @return signature as hex encoded string.
	 * @throws InvalidAlgorithmParameterException
	 *            on invalid or inappropriate algorithm parameters
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 * @throws InvalidKeyException
	 *            if key is not RSA or DSA.
	 * @throws SignatureException
	 *            on signature error
	 */
	public static String sign(final PrivateKey privateKey, final byte[] data,
			final Version version) throws InvalidAlgorithmParameterException,
			InvalidKeyException, NoSuchAlgorithmException, SignatureException {
<span class="fc" id="L299">		final Signature signature = getSignature(privateKey, version);</span>
<span class="fc" id="L300">		signature.initSign(privateKey);</span>
<span class="fc" id="L301">		configureSignature(privateKey, version, signature);</span>
<span class="fc" id="L302">		signature.update(data);</span>
<span class="fc" id="L303">		return Base64.getEncoder().encodeToString(signature.sign());</span>
	}

	/**
	 * A convenience method that chooses a signature algorithm based on the key
	 * type. Works with DSA and RSA keys.
	 *
	 * @param publicKey
	 *            public key corresponding to private key that generated
	 *            signature.
	 * @param data
	 *            data/hash to verify
	 * @param allegedSignature
	 *            to try and verify with
	 * @return boolean
	 * @throws InvalidAlgorithmParameterException
	 *            on invalid or inappropriate algorithm parameters
	 * @throws InvalidKeyException
	 *            if key is not RSA or DSA.
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 * @throws SignatureException
	 *            on signature error
	 */
	public static boolean verify(final PublicKey publicKey, final byte[] data,
			final String allegedSignature)
			throws InvalidAlgorithmParameterException, InvalidKeyException,
			NoSuchAlgorithmException, SignatureException {
<span class="fc" id="L331">		return verify(publicKey, data, allegedSignature, Version.SIGNATURE_V1);</span>
	}

	/**
	 * Verify a signature.
	 *
	 * @param publicKey
	 *            public key corresponding to private key that generated
	 *            signature.
	 * @param data
	 *            the data/hash that was signed.
	 * @param allegedSignature
	 *            the signature being verified.
	 * @param version
	 *            signature version.
	 * @return true if computed signature matches allegedSignature.
	 * @throws InvalidAlgorithmParameterException
	 *            on invalid or inappropriate algorithm parameters
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 * @throws InvalidKeyException
	 *            if key is not RSA or DSA.
	 * @throws SignatureException
	 *            on signature error
	 */
	public static boolean verify(final PublicKey publicKey, final byte[] data,
			final String allegedSignature, final Version version)
			throws InvalidAlgorithmParameterException, InvalidKeyException,
			NoSuchAlgorithmException, SignatureException {
<span class="fc" id="L360">		final Signature signature = getSignature(publicKey, version);</span>
<span class="fc" id="L361">		signature.initVerify(publicKey);</span>
<span class="fc" id="L362">		configureSignature(publicKey, version, signature);</span>
<span class="fc" id="L363">		signature.update(data);</span>
<span class="fc" id="L364">		return signature.verify(Base64.getDecoder().decode(allegedSignature));</span>
	}

	/**
	 * A convenience method to encrypt a byte array.
	 *
	 * @param key
	 *            a key that can be used to encrypt.
	 * @param toEncrypt
	 *            the data to encrypt.
	 * @return encrypted byte array.
	 * @throws InvalidKeyException
	 *            if key is not RSA or DSA.
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 * @throws NoSuchPaddingException
	 *            on invalid padding
	 * @throws IllegalArgumentException
	 *            on illegal args passed to function
	 * @throws IOException
	 *            on IO error
	 */
	public static byte[] encrypt(final Key key, final byte[] toEncrypt)
			throws InvalidKeyException, NoSuchAlgorithmException,
			NoSuchPaddingException, IllegalArgumentException, IOException {
<span class="fc" id="L389">		ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L390">		processCipherStream(getEncryptCipher(key),</span>
<span class="fc" id="L391">				StreamUtils.getInputStream(toEncrypt), baos);</span>
<span class="fc" id="L392">		return baos.toByteArray();</span>
	}

	/**
	 * A convenience method to decrypt a byte array.
	 *
	 * @param key
	 *            a key that can be used to decrypt.
	 * @param toDecrypt
	 *            the data to decrypt.
	 * @return decrypted byte array.
	 * @throws InvalidKeyException
	 *            if key is not RSA or DSA.
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 * @throws NoSuchPaddingException
	 *            on invalid padding
	 * @throws IllegalArgumentException
	 *            on illegal args passed to function
	 * @throws IOException
	 *            on IO error
	 */
	public static byte[] decrypt(final Key key, final byte[] toDecrypt)
			throws InvalidKeyException, NoSuchAlgorithmException,
			NoSuchPaddingException, IllegalArgumentException, IOException {
<span class="fc" id="L417">		ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L418">		processCipherStream(getDecryptCipher(key),</span>
<span class="fc" id="L419">				StreamUtils.getInputStream(toDecrypt), baos);</span>
<span class="fc" id="L420">		return baos.toByteArray();</span>
	}

	/**
	 * Generate a new symmetric encryption key.
	 *
	 * @param bits
	 *            how many bits. This should be AES_128 or AES256.
	 * @return generated AES key.
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 */
	public static Key generateAESKey(final int bits)
			throws NoSuchAlgorithmException {
<span class="fc" id="L434">		KeyGenerator gen = KeyGenerator.getInstance(AES_ALGORITHM);</span>
<span class="fc" id="L435">		gen.init(bits);</span>
<span class="fc" id="L436">		return gen.generateKey();</span>
	}

	/**
	 * Generate a new asymmetric encryption key pair.
	 *
	 * @param bits
	 *            how many bits. Must be a valid RSA size.
	 * @return generated RSA key pair.
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 */
	public static KeyPair generateRSAKeyPair(final int bits)
			throws NoSuchAlgorithmException {
<span class="fc" id="L450">		KeyPairGenerator gen = KeyPairGenerator.getInstance(RSA_ALGORITHM);</span>
<span class="fc" id="L451">		gen.initialize(bits);</span>
<span class="fc" id="L452">		return gen.generateKeyPair();</span>
	}

	/**
	 * Generate a new asymmetric signature key pair.
	 *
	 * @param bits
	 *            how many bits. Must be a valid DSA size.
	 * @return generated DSA key pair.
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 */
	public static KeyPair generateDSAKeyPair(final int bits)
			throws NoSuchAlgorithmException {
<span class="fc" id="L466">		KeyPairGenerator gen = KeyPairGenerator.getInstance(DSA_ALGORITHM);</span>
<span class="fc" id="L467">		gen.initialize(bits);</span>
<span class="fc" id="L468">		return gen.generateKeyPair();</span>
	}

	/**
	 * Read a X509 encoded certificate. May be DER or PEM encoded.
	 *
	 * @param bytes
	 *            the certificate data as a byte array.
	 * @return parsed certificate.
	 * @throws CertificateException
	 *            on certificate issue
	 * @throws IOException
	 *            on IO error
	 */
	public static Certificate readCertificate(final byte[] bytes)
			throws CertificateException, IOException {
<span class="nc" id="L484">		byte[] data = bytes;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">		if (((char) data[0]) == '-') {</span>
<span class="nc" id="L486">			data = convertPEMToDER(new String(data));</span>
		}
<span class="nc" id="L488">		Certificate certificate = CertificateFactory.getInstance(&quot;X.509&quot;)</span>
<span class="nc" id="L489">				.generateCertificate(new ByteArrayInputStream(data));</span>
<span class="nc" id="L490">		return certificate;</span>
	}

	/**
	 * Read a X509 encoded public key. May be DER or PEM encoded.
	 *
	 * @param bytes
	 *            the key data as a byte array.
	 * @return parsed public key.
	 * @throws IOException
	 *            on IO error
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 */
	public static PublicKey readPublicKey(final byte[] bytes)
			throws IOException, NoSuchAlgorithmException {
<span class="fc" id="L506">		byte[] data = bytes;</span>
		// decode from PEM format
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">		if (((char) data[0]) == '-') {</span>
<span class="fc" id="L509">			data = convertPEMToDER(new String(data));</span>
		}
<span class="fc" id="L511">		X509EncodedKeySpec spec = new X509EncodedKeySpec(data);</span>

		try {
<span class="nc" id="L514">			return KeyFactory.getInstance(DSA_ALGORITHM).generatePublic(spec);</span>
<span class="fc" id="L515">		} catch (InvalidKeySpecException e) {</span>
			try {
<span class="fc" id="L517">				return KeyFactory.getInstance(RSA_ALGORITHM).generatePublic(</span>
						spec);
<span class="nc" id="L519">			} catch (InvalidKeySpecException e2) {</span>
				// ignore
			}
		}

<span class="nc" id="L524">		return null;</span>
	}

	/**
	 * Read a PKCS#8 encoded private key. May be DER or PEM encoded.
	 *
	 * @param bytes
	 *            the key data as a byte array.
	 * @return parsed private key.
	 * @throws IOException
	 *            on IO error
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 */
	public static PrivateKey readPrivateKey(final byte[] bytes)
			throws IOException, NoSuchAlgorithmException {
<span class="fc" id="L540">		byte[] data = bytes;</span>
		// decode from PEM format
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">		if (((char) data[0]) == '-') {</span>
<span class="fc" id="L543">			data = convertPEMToDER(new String(data));</span>
		}
<span class="fc" id="L545">		PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(data);</span>

		try {
<span class="nc" id="L548">			return KeyFactory.getInstance(DSA_ALGORITHM).generatePrivate(spec);</span>
<span class="fc" id="L549">		} catch (InvalidKeySpecException e) {</span>
			try {
<span class="fc" id="L551">				return KeyFactory.getInstance(RSA_ALGORITHM).generatePrivate(</span>
						spec);
<span class="nc" id="L553">			} catch (InvalidKeySpecException e2) {</span>
				// ignore
			}
		}

<span class="nc" id="L558">		return null;</span>
	}

	/**
	 * Read an OpenSSH private key from a stream.
	 *
	 * @param bytes
	 *            the byte array containing an OpenSSH private key.
	 * @param password
	 *            password if the key is encrypted.
	 * @return decoded PrivateKey.
	 * @throws IOException
	 *            on IO error
	 * @throws InvalidKeySpecException
	 *            when key has invalid specifications
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 */
	public static PrivateKey readOpenSSHPrivateKey(final byte[] bytes,
			final String password) throws IOException,
			NoSuchAlgorithmException, InvalidKeySpecException {
<span class="fc" id="L579">		PrivateKey key = null;</span>

		// this returns an ethz DSAPrivateKey or RSAPrivateKey
<span class="fc" id="L582">		Object obj = PEMDecoder.decode(new String(bytes).toCharArray(),</span>
				password);

<span class="fc bfc" id="L585" title="All 2 branches covered.">		if (obj instanceof ch.ethz.ssh2.signature.DSAPrivateKey) {</span>
<span class="fc" id="L586">			ch.ethz.ssh2.signature.DSAPrivateKey ethzDSAKey = (ch.ethz.ssh2.signature.DSAPrivateKey) obj;</span>
<span class="fc" id="L587">			key = (DSAPrivateKey) KeyFactory.getInstance(&quot;DSA&quot;)</span>
<span class="fc" id="L588">					.generatePrivate(</span>
<span class="fc" id="L589">							new DSAPrivateKeySpec(ethzDSAKey.getX(), ethzDSAKey</span>
<span class="fc" id="L590">									.getP(), ethzDSAKey.getQ(), ethzDSAKey</span>
<span class="fc" id="L591">									.getG()));</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">		} else if (obj instanceof ch.ethz.ssh2.signature.RSAPrivateKey) {</span>
<span class="fc" id="L593">			ch.ethz.ssh2.signature.RSAPrivateKey ethzRSAKey = (ch.ethz.ssh2.signature.RSAPrivateKey) obj;</span>
<span class="fc" id="L594">			key = (RSAPrivateKey) KeyFactory.getInstance(&quot;RSA&quot;)</span>
<span class="fc" id="L595">					.generatePrivate(</span>
<span class="fc" id="L596">							new RSAPrivateKeySpec(ethzRSAKey.getN(), ethzRSAKey</span>
<span class="fc" id="L597">									.getD()));</span>
		}

<span class="fc" id="L600">		return key;</span>
	}

	/**
	 * Read an OpenSSH PublicKey from a stream.
	 *
	 * @param bytes
	 *            bytes to read.
	 * @return a publicKey
	 * @throws IOException
	 *            on IO error
	 * @throws NoSuchAlgorithmException
	 *            on invalid algorithm
	 * @throws InvalidKeySpecException
	 *            when key has invalid specifications
	 */
	public static PublicKey readOpenSSHPublicKey(final byte[] bytes)
			throws IOException, InvalidKeySpecException,
			NoSuchAlgorithmException {

		// format is &lt;type&gt;&lt;space&gt;&lt;base64data&gt;&lt;space&gt;&lt;comment&gt;
<span class="fc" id="L621">		String[] line = new String(bytes).trim().split(&quot; &quot;, 3);</span>
<span class="fc" id="L622">		String type = line[0];</span>
<span class="fc" id="L623">		String content = line[1];</span>
		// String comment = line[2];

<span class="fc" id="L626">		ByteBuffer buf = ByteBuffer.wrap(Base64.getDecoder().decode(content));</span>

		// format of decoded content is: &lt;type&gt;&lt;keyparams&gt;
		// where type and each param is a DER string
<span class="fc" id="L630">		String decodedType = new String(readDERString(buf));</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">		if (!decodedType.equals(type)) {</span>
<span class="nc" id="L632">			throw new IllegalArgumentException(&quot;expected &quot; + type + &quot;, got &quot;</span>
					+ decodedType);
		}
<span class="fc bfc" id="L635" title="All 2 branches covered.">		if (type.equals(&quot;ssh-dss&quot;)) {</span>
			// dsa key params are p, q, g, y
<span class="fc" id="L637">			BigInteger p = new BigInteger(readDERString(buf));</span>
<span class="fc" id="L638">			BigInteger q = new BigInteger(readDERString(buf));</span>
<span class="fc" id="L639">			BigInteger g = new BigInteger(readDERString(buf));</span>
<span class="fc" id="L640">			BigInteger y = new BigInteger(readDERString(buf));</span>
<span class="fc" id="L641">			return KeyFactory.getInstance(DSA_ALGORITHM).generatePublic(</span>
					new DSAPublicKeySpec(y, p, q, g));
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">		} else if (type.equals(&quot;ssh-rsa&quot;)) {</span>
			// rsa key params are e, y
<span class="fc" id="L645">			BigInteger e = new BigInteger(readDERString(buf));</span>
<span class="fc" id="L646">			BigInteger y = new BigInteger(readDERString(buf));</span>
<span class="fc" id="L647">			return KeyFactory.getInstance(RSA_ALGORITHM).generatePublic(</span>
					new RSAPublicKeySpec(y, e));
		} else {
<span class="nc" id="L650">			throw new InvalidKeySpecException(&quot;Unknown key type '&quot; + type + &quot;'&quot;);</span>
		}
	}

	/**
	 * This method reads a DER encoded byte string from a ByteBuffer.
	 *
	 * A DER encoded string has
	 *
	 * length = 4 bytes big-endian integer&lt;br&gt;
	 * string = length bytes
	 *
	 * @param buf
	 *            buffer containing DER encoded bytes.
	 * @return bytes the decoded bytes.
	 */
	public static byte[] readDERString(ByteBuffer buf) {
<span class="fc" id="L667">		int length = buf.getInt();</span>
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">		if (length &gt; 8192) {</span>
<span class="nc" id="L669">			throw new IllegalArgumentException(&quot;DER String Length &quot; + length</span>
					+ &quot; &gt; 8192&quot;);
		}
<span class="fc" id="L672">		byte[] bytes = new byte[length];</span>
<span class="fc" id="L673">		buf.get(bytes);</span>
<span class="fc" id="L674">		return bytes;</span>
	}

	/**
	 * Read a PEM format.
	 *
	 * This does not currently support encrypted PEM formats.
	 *
	 * @param string
	 *            string containing PEM formatted data.
	 * @return DER formatted data.
	 * @throws IOException
	 *            on IO error
	 */
	public static byte[] convertPEMToDER(final String string)
			throws IOException {
<span class="fc" id="L690">		List&lt;String&gt; lines = StringUtils.split(string, &quot;\n&quot;);</span>
<span class="fc" id="L691">		String header = lines.remove(0);</span>
<span class="fc" id="L692">		String footer = lines.remove(lines.size() - 1);</span>
		String type;

<span class="pc bpc" id="L695" title="2 of 4 branches missed.">		if (header.startsWith(&quot;-----BEGIN &quot;) &amp;&amp; header.endsWith(&quot;-----&quot;)) {</span>
<span class="fc" id="L696">			type = header;</span>
<span class="fc" id="L697">			type = type.replace(&quot;-----BEGIN &quot;, &quot;&quot;);</span>
<span class="fc" id="L698">			type = type.replace(&quot;-----&quot;, &quot;&quot;);</span>

<span class="pc bpc" id="L700" title="1 of 2 branches missed.">			if (type.contains(&quot;ENCRYPTED&quot;)) {</span>
<span class="nc" id="L701">				throw new IllegalArgumentException(</span>
						&quot;Encrypted keys are not supported.&quot;);
			}

<span class="pc bpc" id="L705" title="1 of 2 branches missed.">			if (footer.equals(&quot;-----END &quot; + type + &quot;-----&quot;)) {</span>
				// expected match
<span class="fc" id="L707">				return Base64.getMimeDecoder().decode(</span>
<span class="fc" id="L708">						StringUtils.join(new LinkedList&lt;Object&gt;(lines), &quot;\n&quot;));</span>
			} else {
<span class="nc" id="L710">				throw new IllegalArgumentException(&quot;Unexpected PEM footer '&quot;</span>
						+ footer + &quot;'&quot;);
			}
		} else {
<span class="nc" id="L714">			throw new IllegalArgumentException(&quot;Unexpected PEM header '&quot;</span>
					+ header + &quot;'&quot;);
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>